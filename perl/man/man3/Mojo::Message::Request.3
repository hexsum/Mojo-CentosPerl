.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojo::Message::Request 3"
.TH Mojo::Message::Request 3 "2016-07-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::Message::Request \- HTTP request
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::Message::Request;
\&
\&  # Parse
\&  my $req = Mojo::Message::Request\->new;
\&  $req\->parse("GET /foo HTTP/1.0\ex0d\ex0a");
\&  $req\->parse("Content\-Length: 12\ex0d\ex0a");
\&  $req\->parse("Content\-Type: text/plain\ex0d\ex0a\ex0d\ex0a");
\&  $req\->parse(\*(AqHello World!\*(Aq);
\&  say $req\->method;
\&  say $req\->headers\->content_type;
\&  say $req\->body;
\&
\&  # Build
\&  my $req = Mojo::Message::Request\->new;
\&  $req\->url\->parse(\*(Aqhttp://127.0.0.1/foo/bar\*(Aq);
\&  $req\->method(\*(AqGET\*(Aq);
\&  say $req\->to_string;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::Message::Request is a container for \s-1HTTP\s0 requests, based on
\&\s-1RFC\s0 7230 <http://tools.ietf.org/html/rfc7230>,
\&\s-1RFC\s0 7231 <http://tools.ietf.org/html/rfc7231>,
\&\s-1RFC\s0 7235 <http://tools.ietf.org/html/rfc7235> and
\&\s-1RFC\s0 2817 <http://tools.ietf.org/html/rfc2817>.
.SH "EVENTS"
.IX Header "EVENTS"
Mojo::Message::Request inherits all events from Mojo::Message.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Mojo::Message::Request inherits all attributes from Mojo::Message and
implements the following new ones.
.SS "env"
.IX Subsection "env"
.Vb 2
\&  my $env = $req\->env;
\&  $req    = $req\->env({PATH_INFO => \*(Aq/\*(Aq});
.Ve
.PP
Direct access to the \f(CW\*(C`CGI\*(C'\fR or \f(CW\*(C`PSGI\*(C'\fR environment hash if available.
.PP
.Vb 2
\&  # Check CGI version
\&  my $version = $req\->env\->{GATEWAY_INTERFACE};
\&
\&  # Check PSGI version
\&  my $version = $req\->env\->{\*(Aqpsgi.version\*(Aq};
.Ve
.SS "method"
.IX Subsection "method"
.Vb 2
\&  my $method = $req\->method;
\&  $req       = $req\->method(\*(AqPOST\*(Aq);
.Ve
.PP
\&\s-1HTTP\s0 request method, defaults to \f(CW\*(C`GET\*(C'\fR.
.SS "proxy"
.IX Subsection "proxy"
.Vb 2
\&  my $url = $req\->proxy;
\&  $req    = $req\->proxy(Mojo::URL\->new(\*(Aqhttp://127.0.0.1:3000\*(Aq));
.Ve
.PP
Proxy \s-1URL\s0 for request.
.SS "reverse_proxy"
.IX Subsection "reverse_proxy"
.Vb 2
\&  my $bool = $req\->reverse_proxy;
\&  $req     = $req\->reverse_proxy($bool);
.Ve
.PP
Request has been performed through a reverse proxy.
.SS "url"
.IX Subsection "url"
.Vb 2
\&  my $url = $req\->url;
\&  $req    = $req\->url(Mojo::URL\->new);
.Ve
.PP
\&\s-1HTTP\s0 request \s-1URL\s0, defaults to a Mojo::URL object.
.PP
.Vb 4
\&  # Get request information
\&  my $info = $req\->url\->to_abs\->userinfo;
\&  my $host = $req\->url\->to_abs\->host;
\&  my $path = $req\->url\->to_abs\->path;
.Ve
.SS "via_proxy"
.IX Subsection "via_proxy"
.Vb 2
\&  my $bool = $req\->via_proxy;
\&  $req     = $req\->via_proxy($bool);
.Ve
.PP
Request can be performed through a proxy server.
.SH "METHODS"
.IX Header "METHODS"
Mojo::Message::Request inherits all methods from Mojo::Message and
implements the following new ones.
.SS "clone"
.IX Subsection "clone"
.Vb 1
\&  my $clone = $req\->clone;
.Ve
.PP
Clone request if possible, otherwise return \f(CW\*(C`undef\*(C'\fR.
.SS "cookies"
.IX Subsection "cookies"
.Vb 3
\&  my $cookies = $req\->cookies;
\&  $req        = $req\->cookies(Mojo::Cookie::Request\->new);
\&  $req        = $req\->cookies({name => \*(Aqfoo\*(Aq, value => \*(Aqbar\*(Aq});
.Ve
.PP
Access request cookies, usually Mojo::Cookie::Request objects.
.PP
.Vb 2
\&  # Names of all cookies
\&  say $_\->name for @{$req\->cookies};
.Ve
.SS "every_param"
.IX Subsection "every_param"
.Vb 1
\&  my $values = $req\->every_param(\*(Aqfoo\*(Aq);
.Ve
.PP
Similar to \*(L"param\*(R", but returns all values sharing the same name as an
array reference.
.PP
.Vb 2
\&  # Get first value
\&  say $req\->every_param(\*(Aqfoo\*(Aq)\->[0];
.Ve
.SS "extract_start_line"
.IX Subsection "extract_start_line"
.Vb 1
\&  my $bool = $req\->extract_start_line(\e$str);
.Ve
.PP
Extract request-line from string.
.SS "fix_headers"
.IX Subsection "fix_headers"
.Vb 1
\&  $req = $req\->fix_headers;
.Ve
.PP
Make sure request has all required headers.
.SS "get_start_line_chunk"
.IX Subsection "get_start_line_chunk"
.Vb 1
\&  my $bytes = $req\->get_start_line_chunk($offset);
.Ve
.PP
Get a chunk of request-line data starting from a specific position. Note that
this method finalizes the request.
.SS "is_handshake"
.IX Subsection "is_handshake"
.Vb 1
\&  my $bool = $req\->is_handshake;
.Ve
.PP
Check \f(CW\*(C`Upgrade\*(C'\fR header for \f(CW\*(C`websocket\*(C'\fR value.
.SS "is_secure"
.IX Subsection "is_secure"
.Vb 1
\&  my $bool = $req\->is_secure;
.Ve
.PP
Check if connection is secure.
.SS "is_xhr"
.IX Subsection "is_xhr"
.Vb 1
\&  my $bool = $req\->is_xhr;
.Ve
.PP
Check \f(CW\*(C`X\-Requested\-With\*(C'\fR header for \f(CW\*(C`XMLHttpRequest\*(C'\fR value.
.SS "param"
.IX Subsection "param"
.Vb 1
\&  my $value = $req\->param(\*(Aqfoo\*(Aq);
.Ve
.PP
Access \f(CW\*(C`GET\*(C'\fR and \f(CW\*(C`POST\*(C'\fR parameters extracted from the query string and
\&\f(CW\*(C`application/x\-www\-form\-urlencoded\*(C'\fR or \f(CW\*(C`multipart/form\-data\*(C'\fR message body. If
there are multiple values sharing the same name, and you want to access more
than just the last one, you can use \*(L"every_param\*(R". Note that this method
caches all data, so it should not be called before the entire request body has
been received. Parts of the request body need to be loaded into memory to parse
\&\f(CW\*(C`POST\*(C'\fR parameters, so you have to make sure it is not excessively large,
there's a 16MB limit by default.
.SS "params"
.IX Subsection "params"
.Vb 1
\&  my $params = $req\->params;
.Ve
.PP
All \f(CW\*(C`GET\*(C'\fR and \f(CW\*(C`POST\*(C'\fR parameters extracted from the query string and
\&\f(CW\*(C`application/x\-www\-form\-urlencoded\*(C'\fR or \f(CW\*(C`multipart/form\-data\*(C'\fR message body,
usually a Mojo::Parameters object. Note that this method caches all data, so
it should not be called before the entire request body has been received. Parts
of the request body need to be loaded into memory to parse \f(CW\*(C`POST\*(C'\fR parameters,
so you have to make sure it is not excessively large, there's a 16MB limit by
default.
.PP
.Vb 2
\&  # Get parameter names and values
\&  my $hash = $req\->params\->to_hash;
.Ve
.SS "parse"
.IX Subsection "parse"
.Vb 2
\&  $req = $req\->parse(\*(AqGET /foo/bar HTTP/1.1\*(Aq);
\&  $req = $req\->parse({PATH_INFO => \*(Aq/\*(Aq});
.Ve
.PP
Parse \s-1HTTP\s0 request chunks or environment hash.
.SS "query_params"
.IX Subsection "query_params"
.Vb 1
\&  my $params = $req\->query_params;
.Ve
.PP
All \f(CW\*(C`GET\*(C'\fR parameters, usually a Mojo::Parameters object.
.PP
.Vb 2
\&  # Turn GET parameters to hash and extract value
\&  say $req\->query_params\->to_hash\->{foo};
.Ve
.SS "start_line_size"
.IX Subsection "start_line_size"
.Vb 1
\&  my $size = $req\->start_line_size;
.Ve
.PP
Size of the request-line in bytes. Note that this method finalizes the request.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicious.org>.
