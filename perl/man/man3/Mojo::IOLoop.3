.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojo::IOLoop 3"
.TH Mojo::IOLoop 3 "2016-09-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::IOLoop \- Minimalistic event loop
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::IOLoop;
\&
\&  # Listen on port 3000
\&  Mojo::IOLoop\->server({port => 3000} => sub {
\&    my ($loop, $stream) = @_;
\&
\&    $stream\->on(read => sub {
\&      my ($stream, $bytes) = @_;
\&
\&      # Process input chunk
\&      say $bytes;
\&
\&      # Write response
\&      $stream\->write(\*(AqHTTP/1.1 200 OK\*(Aq);
\&    });
\&  });
\&
\&  # Connect to port 3000
\&  my $id = Mojo::IOLoop\->client({port => 3000} => sub {
\&    my ($loop, $err, $stream) = @_;
\&
\&    $stream\->on(read => sub {
\&      my ($stream, $bytes) = @_;
\&
\&      # Process input
\&      say "Input: $bytes";
\&    });
\&
\&    # Write request
\&    $stream\->write("GET / HTTP/1.1\ex0d\ex0a\ex0d\ex0a");
\&  });
\&
\&  # Add a timer
\&  Mojo::IOLoop\->timer(5 => sub {
\&    my $loop = shift;
\&    $loop\->remove($id);
\&  });
\&
\&  # Start event loop if necessary
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::IOLoop is a very minimalistic event loop based on Mojo::Reactor, it
has been reduced to the absolute minimal feature set required to build solid
and scalable non-blocking \s-1TCP\s0 clients and servers.
.PP
Depending on operating system, the default per-process and system-wide file
descriptor limits are often very low and need to be tuned for better
scalability. The \f(CW\*(C`LIBEV_FLAGS\*(C'\fR environment variable should also be used to
select the best possible \s-1EV\s0 backend, which usually defaults to the not very
scalable \f(CW\*(C`select\*(C'\fR.
.PP
.Vb 4
\&  LIBEV_FLAGS=1   # select
\&  LIBEV_FLAGS=2   # poll
\&  LIBEV_FLAGS=4   # epoll (Linux)
\&  LIBEV_FLAGS=8   # kqueue (*BSD, OS X)
.Ve
.PP
The event loop will be resilient to time jumps if a monotonic clock is
available through Time::HiRes. A \s-1TLS\s0 certificate and key are also built
right in, to make writing test servers as easy as possible. Also note that for
convenience the \f(CW\*(C`PIPE\*(C'\fR signal will be set to \f(CW\*(C`IGNORE\*(C'\fR when Mojo::IOLoop is
loaded.
.PP
For better scalability (epoll, kqueue) and to provide non-blocking name
resolution, \s-1SOCKS5\s0 as well as \s-1TLS\s0 support, the optional modules \s-1EV\s0 (4.0+),
Net::DNS::Native (0.15+), IO::Socket::Socks (0.64+) and
IO::Socket::SSL (1.94+) will be used automatically if possible. Individual
features can also be disabled with the \f(CW\*(C`MOJO_NO_NDN\*(C'\fR, \f(CW\*(C`MOJO_NO_SOCKS\*(C'\fR and
\&\f(CW\*(C`MOJO_NO_TLS\*(C'\fR environment variables.
.PP
See \*(L"REAL-TIME \s-1WEB\s0\*(R" in Mojolicious::Guides::Cookbook for more.
.SH "EVENTS"
.IX Header "EVENTS"
Mojo::IOLoop inherits all events from Mojo::EventEmitter and can emit the
following new ones.
.SS "finish"
.IX Subsection "finish"
.Vb 4
\&  $loop\->on(finish => sub {
\&    my $loop = shift;
\&    ...
\&  });
.Ve
.PP
Emitted when the event loop wants to shut down gracefully and is just waiting
for all existing connections to be closed.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Mojo::IOLoop implements the following attributes.
.SS "max_accepts"
.IX Subsection "max_accepts"
.Vb 2
\&  my $max = $loop\->max_accepts;
\&  $loop   = $loop\->max_accepts(1000);
.Ve
.PP
The maximum number of connections this event loop is allowed to accept, before
shutting down gracefully without interrupting existing connections, defaults to
\&\f(CW0\fR. Setting the value to \f(CW0\fR will allow this event loop to accept new
connections indefinitely. Note that up to half of this value can be subtracted
randomly to improve load balancing between multiple server processes.
.SS "max_connections"
.IX Subsection "max_connections"
.Vb 2
\&  my $max = $loop\->max_connections;
\&  $loop   = $loop\->max_connections(100);
.Ve
.PP
The maximum number of accepted connections this event loop is allowed to handle
concurrently, before stopping to accept new incoming connections, defaults to
\&\f(CW1000\fR.
.SS "reactor"
.IX Subsection "reactor"
.Vb 2
\&  my $reactor = $loop\->reactor;
\&  $loop       = $loop\->reactor(Mojo::Reactor\->new);
.Ve
.PP
Low-level event reactor, usually a Mojo::Reactor::Poll or
Mojo::Reactor::EV object with a default subscriber to the event
\&\*(L"error\*(R" in Mojo::Reactor.
.PP
.Vb 5
\&  # Watch if handle becomes readable or writable
\&  $loop\->reactor\->io($handle => sub {
\&    my ($reactor, $writable) = @_;
\&    say $writable ? \*(AqHandle is writable\*(Aq : \*(AqHandle is readable\*(Aq;
\&  });
\&
\&  # Change to watching only if handle becomes writable
\&  $loop\->reactor\->watch($handle, 0, 1);
\&
\&  # Remove handle again
\&  $loop\->reactor\->remove($handle);
.Ve
.SH "METHODS"
.IX Header "METHODS"
Mojo::IOLoop inherits all methods from Mojo::EventEmitter and implements
the following new ones.
.SS "acceptor"
.IX Subsection "acceptor"
.Vb 3
\&  my $server = Mojo::IOLoop\->acceptor($id);
\&  my $server = $loop\->acceptor($id);
\&  my $id     = $loop\->acceptor(Mojo::IOLoop::Server\->new);
.Ve
.PP
Get Mojo::IOLoop::Server object for id or turn object into an acceptor.
.SS "client"
.IX Subsection "client"
.Vb 4
\&  my $id
\&    = Mojo::IOLoop\->client(address => \*(Aq127.0.0.1\*(Aq, port => 3000, sub {...});
\&  my $id = $loop\->client(address => \*(Aq127.0.0.1\*(Aq, port => 3000, sub {...});
\&  my $id = $loop\->client({address => \*(Aq127.0.0.1\*(Aq, port => 3000} => sub {...});
.Ve
.PP
Open \s-1TCP\s0 connection with Mojo::IOLoop::Client, takes the same arguments as
\&\*(L"connect\*(R" in Mojo::IOLoop::Client.
.PP
.Vb 5
\&  # Connect to 127.0.0.1 on port 3000
\&  Mojo::IOLoop\->client({port => 3000} => sub {
\&    my ($loop, $err, $stream) = @_;
\&    ...
\&  });
.Ve
.SS "delay"
.IX Subsection "delay"
.Vb 4
\&  my $delay = Mojo::IOLoop\->delay;
\&  my $delay = $loop\->delay;
\&  my $delay = $loop\->delay(sub {...});
\&  my $delay = $loop\->delay(sub {...}, sub {...});
.Ve
.PP
Build Mojo::IOLoop::Delay object to manage callbacks and control the flow of
events for this event loop, which can help you avoid deep nested closures that
often result from continuation-passing style. Callbacks will be passed along to
\&\*(L"steps\*(R" in Mojo::IOLoop::Delay.
.PP
.Vb 10
\&  # Synchronize multiple non\-blocking operations
\&  my $delay = Mojo::IOLoop\->delay(sub { say \*(AqBOOM!\*(Aq });
\&  for my $i (1 .. 10) {
\&    my $end = $delay\->begin;
\&    Mojo::IOLoop\->timer($i => sub {
\&      say 10 \- $i;
\&      $end\->();
\&    });
\&  }
\&  $delay\->wait;
\&
\&  # Sequentialize multiple non\-blocking operations
\&  Mojo::IOLoop\->delay(
\&
\&    # First step (simple timer)
\&    sub {
\&      my $delay = shift;
\&      Mojo::IOLoop\->timer(2 => $delay\->begin);
\&      say \*(AqSecond step in 2 seconds.\*(Aq;
\&    },
\&
\&    # Second step (concurrent timers)
\&    sub {
\&      my $delay = shift;
\&      Mojo::IOLoop\->timer(1 => $delay\->begin);
\&      Mojo::IOLoop\->timer(3 => $delay\->begin);
\&      say \*(AqThird step in 3 seconds.\*(Aq;
\&    },
\&
\&    # Third step (the end)
\&    sub { say \*(AqAnd done after 5 seconds total.\*(Aq }
\&  )\->wait;
\&
\&  # Handle exceptions in all steps
\&  Mojo::IOLoop\->delay(
\&    sub {
\&      my $delay = shift;
\&      die \*(AqIntentional error\*(Aq;
\&    },
\&    sub {
\&      my ($delay, @args) = @_;
\&      say \*(AqNever actually reached.\*(Aq;
\&    }
\&  )\->catch(sub {
\&    my ($delay, $err) = @_;
\&    say "Something went wrong: $err";
\&  })\->wait;
.Ve
.SS "is_running"
.IX Subsection "is_running"
.Vb 2
\&  my $bool = Mojo::IOLoop\->is_running;
\&  my $bool = $loop\->is_running;
.Ve
.PP
Check if event loop is running.
.PP
.Vb 1
\&  exit unless Mojo::IOLoop\->is_running;
.Ve
.SS "next_tick"
.IX Subsection "next_tick"
.Vb 2
\&  my $undef = Mojo::IOLoop\->next_tick(sub {...});
\&  my $undef = $loop\->next_tick(sub {...});
.Ve
.PP
Execute callback as soon as possible, but not before returning or other
callbacks that have been registered with this method, always returns \f(CW\*(C`undef\*(C'\fR.
.PP
.Vb 5
\&  # Perform operation on next reactor tick
\&  Mojo::IOLoop\->next_tick(sub {
\&    my $loop = shift;
\&    ...
\&  });
.Ve
.SS "one_tick"
.IX Subsection "one_tick"
.Vb 2
\&  Mojo::IOLoop\->one_tick;
\&  $loop\->one_tick;
.Ve
.PP
Run event loop until an event occurs. Note that this method can recurse back
into the reactor, so you need to be careful.
.PP
.Vb 4
\&  # Don\*(Aqt block longer than 0.5 seconds
\&  my $id = Mojo::IOLoop\->timer(0.5 => sub {});
\&  Mojo::IOLoop\->one_tick;
\&  Mojo::IOLoop\->remove($id);
.Ve
.SS "recurring"
.IX Subsection "recurring"
.Vb 3
\&  my $id = Mojo::IOLoop\->recurring(3 => sub {...});
\&  my $id = $loop\->recurring(0 => sub {...});
\&  my $id = $loop\->recurring(0.25 => sub {...});
.Ve
.PP
Create a new recurring timer, invoking the callback repeatedly after a given
amount of time in seconds.
.PP
.Vb 5
\&  # Perform operation every 5 seconds
\&  Mojo::IOLoop\->recurring(5 => sub {
\&    my $loop = shift;
\&    ...
\&  });
.Ve
.SS "remove"
.IX Subsection "remove"
.Vb 2
\&  Mojo::IOLoop\->remove($id);
\&  $loop\->remove($id);
.Ve
.PP
Remove anything with an id, connections will be dropped gracefully by allowing
them to finish writing all data in their write buffers.
.SS "reset"
.IX Subsection "reset"
.Vb 2
\&  Mojo::IOLoop\->reset;
\&  $loop\->reset;
.Ve
.PP
Remove everything and stop the event loop.
.SS "server"
.IX Subsection "server"
.Vb 3
\&  my $id = Mojo::IOLoop\->server(port => 3000, sub {...});
\&  my $id = $loop\->server(port => 3000, sub {...});
\&  my $id = $loop\->server({port => 3000} => sub {...});
.Ve
.PP
Accept \s-1TCP\s0 connections with Mojo::IOLoop::Server, takes the same arguments
as \*(L"listen\*(R" in Mojo::IOLoop::Server.
.PP
.Vb 5
\&  # Listen on port 3000
\&  Mojo::IOLoop\->server({port => 3000} => sub {
\&    my ($loop, $stream, $id) = @_;
\&    ...
\&  });
\&
\&  # Listen on random port
\&  my $id = Mojo::IOLoop\->server({address => \*(Aq127.0.0.1\*(Aq} => sub {
\&    my ($loop, $stream, $id) = @_;
\&    ...
\&  });
\&  my $port = Mojo::IOLoop\->acceptor($id)\->port;
.Ve
.SS "singleton"
.IX Subsection "singleton"
.Vb 1
\&  my $loop = Mojo::IOLoop\->singleton;
.Ve
.PP
The global Mojo::IOLoop singleton, used to access a single shared event loop
object from everywhere inside the process.
.PP
.Vb 3
\&  # Many methods also allow you to take shortcuts
\&  Mojo::IOLoop\->timer(2 => sub { Mojo::IOLoop\->stop });
\&  Mojo::IOLoop\->start;
\&
\&  # Restart active timer
\&  my $id = Mojo::IOLoop\->timer(3 => sub { say \*(AqTimeout!\*(Aq });
\&  Mojo::IOLoop\->singleton\->reactor\->again($id);
\&
\&  # Turn file descriptor into handle and watch if it becomes readable
\&  my $handle = IO::Handle\->new_from_fd($fd, \*(Aqr\*(Aq);
\&  Mojo::IOLoop\->singleton\->reactor\->io($handle => sub {
\&    my ($reactor, $writable) = @_;
\&    say $writable ? \*(AqHandle is writable\*(Aq : \*(AqHandle is readable\*(Aq;
\&  })\->watch($handle, 1, 0);
.Ve
.SS "start"
.IX Subsection "start"
.Vb 2
\&  Mojo::IOLoop\->start;
\&  $loop\->start;
.Ve
.PP
Start the event loop, this will block until \*(L"stop\*(R" is called. Note that
some reactors stop automatically if there are no events being watched anymore.
.PP
.Vb 2
\&  # Start event loop only if it is not running already
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SS "stop"
.IX Subsection "stop"
.Vb 2
\&  Mojo::IOLoop\->stop;
\&  $loop\->stop;
.Ve
.PP
Stop the event loop, this will not interrupt any existing connections and the
event loop can be restarted by running \*(L"start\*(R" again.
.SS "stop_gracefully"
.IX Subsection "stop_gracefully"
.Vb 2
\&  Mojo::IOLoop\->stop_gracefully;
\&  $loop\->stop_gracefully;
.Ve
.PP
Stop accepting new connections and wait for already accepted connections to be
closed, before stopping the event loop.
.SS "stream"
.IX Subsection "stream"
.Vb 3
\&  my $stream = Mojo::IOLoop\->stream($id);
\&  my $stream = $loop\->stream($id);
\&  my $id     = $loop\->stream(Mojo::IOLoop::Stream\->new);
.Ve
.PP
Get Mojo::IOLoop::Stream object for id or turn object into a connection.
.PP
.Vb 2
\&  # Increase inactivity timeout for connection to 300 seconds
\&  Mojo::IOLoop\->stream($id)\->timeout(300);
.Ve
.SS "subprocess"
.IX Subsection "subprocess"
.Vb 2
\&  my $subprocess = Mojo::IOLoop\->subprocess(sub {...}, sub {...});
\&  my $subprocess = $loop\->subprocess(sub {...}, sub {...});
.Ve
.PP
Build Mojo::IOLoop::Subprocess object to perform computationally expensive
operations in subprocesses, without blocking the event loop. Callbacks will be
passed along to \*(L"run\*(R" in Mojo::IOLoop::Subprocess. Note that this method is
\&\s-1EXPERIMENTAL\s0 and might change without warning!
.PP
.Vb 10
\&  # Operation that would block the event loop for 5 seconds
\&  Mojo::IOLoop\->subprocess(
\&    sub {
\&      my $subprocess = shift;
\&      sleep 5;
\&      return \*(AqX\*(Aq, \*(AqMojolicious\*(Aq;
\&    },
\&    sub {
\&      my ($subprocess, $err, @results) = @_;
\&      say "Subprocess error: $err" and return if $err;
\&      say "I $results[0] $results[1]!";
\&    }
\&  );
.Ve
.SS "timer"
.IX Subsection "timer"
.Vb 3
\&  my $id = Mojo::IOLoop\->timer(3 => sub {...});
\&  my $id = $loop\->timer(0 => sub {...});
\&  my $id = $loop\->timer(0.25 => sub {...});
.Ve
.PP
Create a new timer, invoking the callback after a given amount of time in
seconds.
.PP
.Vb 5
\&  # Perform operation in 5 seconds
\&  Mojo::IOLoop\->timer(5 => sub {
\&    my $loop = shift;
\&    ...
\&  });
.Ve
.SH "DEBUGGING"
.IX Header "DEBUGGING"
You can set the \f(CW\*(C`MOJO_IOLOOP_DEBUG\*(C'\fR environment variable to get some advanced
diagnostics information printed to \f(CW\*(C`STDERR\*(C'\fR.
.PP
.Vb 1
\&  MOJO_IOLOOP_DEBUG=1
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicious.org>.
