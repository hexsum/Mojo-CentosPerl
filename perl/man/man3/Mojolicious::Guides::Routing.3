.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojolicious::Guides::Routing 3"
.TH Mojolicious::Guides::Routing 3 "2016-08-15" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojolicious::Guides::Routing \- Routing requests
.SH "OVERVIEW"
.IX Header "OVERVIEW"
This document contains a simple and fun introduction to the Mojolicious
router and its underlying concepts.
.SH "CONCEPTS"
.IX Header "CONCEPTS"
Essentials every Mojolicious developer should know.
.SS "Dispatcher"
.IX Subsection "Dispatcher"
The foundation of every web framework is a tiny black box connecting incoming
requests with code generating the appropriate response.
.PP
.Vb 1
\&  GET /user/show/1 \-> $c\->render(text => \*(AqDaniel\*(Aq);
.Ve
.PP
This black box is usually called a dispatcher. There are many implementations
using different strategies to establish these connections, but pretty much all
are based around mapping the path part of the request \s-1URL\s0 to some kind of
response generator.
.PP
.Vb 4
\&  /user/show/2 \-> $c\->render(text => \*(AqIsabell\*(Aq);
\&  /user/show/3 \-> $c\->render(text => \*(AqSara\*(Aq);
\&  /user/show/4 \-> $c\->render(text => \*(AqStefan\*(Aq);
\&  /user/show/5 \-> $c\->render(text => \*(AqFynn\*(Aq);
.Ve
.PP
While it is very well possible to make all these connections static, it is also
rather inefficient. That's why regular expressions are commonly used to make
the dispatch process more dynamic.
.PP
.Vb 1
\&  qr!/user/show/(\ed+)! \-> $c\->render(text => $users{$1});
.Ve
.PP
Modern dispatchers have pretty much everything \s-1HTTP\s0 has to offer at their
disposal and can use many more variables than just the request path, such as
request method and headers like \f(CW\*(C`Host\*(C'\fR, \f(CW\*(C`User\-Agent\*(C'\fR and \f(CW\*(C`Accept\*(C'\fR.
.PP
.Vb 4
\&  GET /user/show/23 HTTP/1.1
\&  Host: mojolicious.org
\&  User\-Agent: Mojolicious (Perl)
\&  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
.Ve
.SS "Routes"
.IX Subsection "Routes"
While regular expressions are quite powerful they also tend to be unpleasant to
look at and are generally overkill for ordinary path matching.
.PP
.Vb 1
\&  qr!/user/show/(\ed+)! \-> $c\->render(text => $users{$1});
.Ve
.PP
This is where routes come into play, they have been designed from the ground up
to represent paths with placeholders.
.PP
.Vb 1
\&  /user/show/:id \-> $c\->render(text => $users{$id});
.Ve
.PP
The only difference between a static path and the route above is the \f(CW\*(C`:id\*(C'\fR
placeholder. One or more placeholders can be anywhere in the route.
.PP
.Vb 1
\&  /user/:action/:id
.Ve
.PP
A fundamental concept of the Mojolicious router is that extracted
placeholder values are turned into a hash.
.PP
.Vb 1
\&  /user/show/23 \-> /user/:action/:id \-> {action => \*(Aqshow\*(Aq, id => 23}
.Ve
.PP
This hash is basically the center of every Mojolicious application, you will
learn more about this later on. Internally, routes get compiled to regular
expressions, so you can get the best of both worlds with a little bit of
experience.
.PP
.Vb 1
\&  /user/show/:id \-> qr/(?\-xism:^\e/user\e/show/([^\e/.]+))/
.Ve
.PP
A trailing slash in the path is always optional.
.PP
.Vb 1
\&  /user/show/23/ \-> /user/:action/:id \-> {action => \*(Aqshow\*(Aq, id => 23}
.Ve
.SS "Reversibility"
.IX Subsection "Reversibility"
One more huge advantage routes have over regular expressions is that they are
easily reversible, extracted placeholders can be turned back into a path at any
time.
.PP
.Vb 2
\&  /sebastian \-> /:name \-> {name => \*(Aqsebastian\*(Aq}
\&  {name => \*(Aqsebastian\*(Aq} \-> /:name \-> /sebastian
.Ve
.PP
Every placeholder has a name, even if it's just an empty string.
.SS "Standard placeholders"
.IX Subsection "Standard placeholders"
Standard placeholders are the simplest form of placeholders, they use a colon
prefix and match all characters except \f(CW\*(C`/\*(C'\fR and \f(CW\*(C`.\*(C'\fR, similar to the regular
expression \f(CW\*(C`([^/.]+)\*(C'\fR.
.PP
.Vb 6
\&  /hello              \-> /:name/hello \-> undef
\&  /sebastian/23/hello \-> /:name/hello \-> undef
\&  /sebastian.23/hello \-> /:name/hello \-> undef
\&  /sebastian/hello    \-> /:name/hello \-> {name => \*(Aqsebastian\*(Aq}
\&  /sebastian23/hello  \-> /:name/hello \-> {name => \*(Aqsebastian23\*(Aq}
\&  /sebastian 23/hello \-> /:name/hello \-> {name => \*(Aqsebastian 23\*(Aq}
.Ve
.PP
All placeholders can be surrounded by parentheses to separate them from the
surrounding text.
.PP
.Vb 6
\&  /hello             \-> /(:name)hello \-> undef
\&  /sebastian/23hello \-> /(:name)hello \-> undef
\&  /sebastian.23hello \-> /(:name)hello \-> undef
\&  /sebastianhello    \-> /(:name)hello \-> {name => \*(Aqsebastian\*(Aq}
\&  /sebastian23hello  \-> /(:name)hello \-> {name => \*(Aqsebastian23\*(Aq}
\&  /sebastian 23hello \-> /(:name)hello \-> {name => \*(Aqsebastian 23\*(Aq}
.Ve
.PP
The colon prefix is optional for standard placeholders that are surrounded by
parentheses.
.PP
.Vb 1
\&  /iXmojolicious \-> /(one)X(two) \-> {one => \*(Aqi\*(Aq, two => \*(Aqmojolicious\*(Aq}
.Ve
.SS "Relaxed placeholders"
.IX Subsection "Relaxed placeholders"
Relaxed placeholders are just like standard placeholders, but use a hash prefix
and match all characters except \f(CW\*(C`/\*(C'\fR, similar to the regular expression
\&\f(CW\*(C`([^/]+)\*(C'\fR.
.PP
.Vb 6
\&  /hello              \-> /#name/hello \-> undef
\&  /sebastian/23/hello \-> /#name/hello \-> undef
\&  /sebastian.23/hello \-> /#name/hello \-> {name => \*(Aqsebastian.23\*(Aq}
\&  /sebastian/hello    \-> /#name/hello \-> {name => \*(Aqsebastian\*(Aq}
\&  /sebastian23/hello  \-> /#name/hello \-> {name => \*(Aqsebastian23\*(Aq}
\&  /sebastian 23/hello \-> /#name/hello \-> {name => \*(Aqsebastian 23\*(Aq}
.Ve
.PP
They can be especially useful for manually matching file names with extensions,
rather than using format detection.
.PP
.Vb 1
\&  /music/song.mp3 \-> /music/#filename \-> {filename => \*(Aqsong.mp3\*(Aq}
.Ve
.SS "Wildcard placeholders"
.IX Subsection "Wildcard placeholders"
Wildcard placeholders are just like the two types of placeholders above, but use
an asterisk prefix and match absolutely everything, including \f(CW\*(C`/\*(C'\fR and \f(CW\*(C`.\*(C'\fR,
similar to the regular expression \f(CW\*(C`(.+)\*(C'\fR.
.PP
.Vb 6
\&  /hello              \-> /*name/hello \-> undef
\&  /sebastian/23/hello \-> /*name/hello \-> {name => \*(Aqsebastian/23\*(Aq}
\&  /sebastian.23/hello \-> /*name/hello \-> {name => \*(Aqsebastian.23\*(Aq}
\&  /sebastian/hello    \-> /*name/hello \-> {name => \*(Aqsebastian\*(Aq}
\&  /sebastian23/hello  \-> /*name/hello \-> {name => \*(Aqsebastian23\*(Aq}
\&  /sebastian 23/hello \-> /*name/hello \-> {name => \*(Aqsebastian 23\*(Aq}
.Ve
.SH "BASICS"
.IX Header "BASICS"
Most commonly used features every Mojolicious developer should know about.
.SS "Minimal route"
.IX Subsection "Minimal route"
The attribute \*(L"routes\*(R" in Mojolicious contains a router you can use to generate
route structures.
.PP
.Vb 3
\&  # Application
\&  package MyApp;
\&  use Mojo::Base \*(AqMojolicious\*(Aq;
\&
\&  sub startup {
\&    my $self = shift;
\&
\&    # Router
\&    my $r = $self\->routes;
\&
\&    # Route
\&    $r\->get(\*(Aq/welcome\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqwelcome\*(Aq);
\&  }
\&
\&  1;
.Ve
.PP
The minimal route above will load and instantiate the class
\&\f(CW\*(C`MyApp::Controller::Foo\*(C'\fR and call its \f(CW\*(C`welcome\*(C'\fR method. Routes are usually
configured in the \f(CW\*(C`startup\*(C'\fR method of the application class, but the router can
be accessed from everywhere (even at runtime).
.PP
.Vb 3
\&  # Controller
\&  package MyApp::Controller::Foo;
\&  use Mojo::Base \*(AqMojolicious::Controller\*(Aq;
\&
\&  # Action
\&  sub welcome {
\&    my $self = shift;
\&
\&    # Render response
\&    $self\->render(text => \*(AqHello there.\*(Aq);
\&  }
\&
\&  1;
.Ve
.PP
All routes match in the same order in which they were defined, and matching
stops as soon as a suitable route has been found. So you can improve the routing
performance by declaring your most frequently accessed routes first. A routing
cache will also be used automatically to handle sudden traffic spikes more
gracefully.
.SS "Routing destination"
.IX Subsection "Routing destination"
After you start a new route with methods like
\&\*(L"get\*(R" in Mojolicious::Routes::Route, you can also give it a destination in the
form of a hash using the chained method \*(L"to\*(R" in Mojolicious::Routes::Route.
.PP
.Vb 2
\&  # /welcome \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqwelcome\*(Aq}
\&  $r\->get(\*(Aq/welcome\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqwelcome\*(Aq);
.Ve
.PP
Now if the route matches an incoming request it will use the content of this
hash to try and find appropriate code to generate a response.
.SS "\s-1HTTP\s0 methods"
.IX Subsection "HTTP methods"
There are already shortcuts for the most common \s-1HTTP\s0 request methods like
\&\*(L"post\*(R" in Mojolicious::Routes::Route, and for more control
\&\*(L"any\*(R" in Mojolicious::Routes::Route accepts an optional array reference with
arbitrary request methods as first argument.
.PP
.Vb 3
\&  # PUT /hello  \-> undef
\&  # GET /hello  \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqhello\*(Aq}
\&  $r\->get(\*(Aq/hello\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqhello\*(Aq);
\&
\&  # PUT /hello \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqhello\*(Aq}
\&  $r\->put(\*(Aq/hello\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqhello\*(Aq);
\&
\&  # POST /hello \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqhello\*(Aq}
\&  $r\->post(\*(Aq/hello\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqhello\*(Aq);
\&
\&  # GET|POST /bye  \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbye\*(Aq}
\&  $r\->any([\*(AqGET\*(Aq, \*(AqPOST\*(Aq] => \*(Aq/bye\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbye\*(Aq);
\&
\&  # * /whatever \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqwhatever\*(Aq}
\&  $r\->any(\*(Aq/whatever\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqwhatever\*(Aq);
.Ve
.PP
There is one small exception, \f(CW\*(C`HEAD\*(C'\fR requests are considered equal to \f(CW\*(C`GET\*(C'\fR,
but content will not be sent with the response even if it is present.
.PP
.Vb 3
\&  # GET /test  \-> {controller => \*(Aqbar\*(Aq, action => \*(Aqtest\*(Aq}
\&  # HEAD /test \-> {controller => \*(Aqbar\*(Aq, action => \*(Aqtest\*(Aq}
\&  $r\->get(\*(Aq/test\*(Aq)\->to(controller => \*(Aqbar\*(Aq, action => \*(Aqtest\*(Aq);
.Ve
.PP
You can also use the \f(CW\*(C`_method\*(C'\fR query parameter to override the request method.
This can be very useful when submitting forms with browsers that only support
\&\f(CW\*(C`GET\*(C'\fR and \f(CW\*(C`POST\*(C'\fR.
.PP
.Vb 3
\&  # PUT  /stuff             \-> {controller => \*(Aqbaz\*(Aq, action => \*(Aqstuff\*(Aq}
\&  # POST /stuff?_method=PUT \-> {controller => \*(Aqbaz\*(Aq, action => \*(Aqstuff\*(Aq}
\&  $r\->put(\*(Aq/stuff\*(Aq)\->to(controller => \*(Aqbaz\*(Aq, action => \*(Aqstuff\*(Aq);
.Ve
.SS "IRIs"
.IX Subsection "IRIs"
IRIs are handled transparently, that means paths are guaranteed to be unescaped
and decoded from bytes to characters.
.PP
.Vb 2
\&  # GET /X (Unicode snowman) \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqsnowman\*(Aq}
\&  $r\->get(\*(Aq/X\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqsnowman\*(Aq);
.Ve
.SS "Stash"
.IX Subsection "Stash"
The generated hash of a matching route is actually the center of the whole
Mojolicious request cycle. We call it the stash, and it persists until a
response has been generated.
.PP
.Vb 3
\&  # /bye \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbye\*(Aq, mymessage => \*(AqBye\*(Aq}
\&  $r\->get(\*(Aq/bye\*(Aq)
\&    \->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbye\*(Aq, mymessage => \*(AqBye\*(Aq);
.Ve
.PP
There are a few stash values with special meaning, such as \f(CW\*(C`controller\*(C'\fR and
\&\f(CW\*(C`action\*(C'\fR, but you can generally fill it with whatever data you need to
generate a response. Once dispatched the whole stash content can be changed at
any time.
.PP
.Vb 2
\&  sub bye {
\&    my $self = shift;
\&
\&    # Get message from stash
\&    my $msg = $self\->stash(\*(Aqmymessage\*(Aq);
\&
\&    # Change message in stash
\&    $self\->stash(mymessage => \*(AqWelcome\*(Aq);
\&  }
.Ve
.PP
For a full list of reserved stash values see
\&\*(L"stash\*(R" in Mojolicious::Controller.
.SS "Nested routes"
.IX Subsection "Nested routes"
It is also possible to build tree structures from routes to remove repetitive
code. A route with children can't match on its own though, only the actual
endpoints of these nested routes can.
.PP
.Vb 4
\&  # /foo     \-> undef
\&  # /foo/bar \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq}
\&  my $foo = $r\->any(\*(Aq/foo\*(Aq)\->to(controller => \*(Aqfoo\*(Aq);
\&  $foo\->get(\*(Aq/bar\*(Aq)\->to(action => \*(Aqbar\*(Aq);
.Ve
.PP
The stash is simply inherited from route to route and newer values override old
ones.
.PP
.Vb 7
\&  # /cats      \-> {controller => \*(Aqcats\*(Aq, action => \*(Aqindex\*(Aq}
\&  # /cats/nyan \-> {controller => \*(Aqcats\*(Aq, action => \*(Aqnyan\*(Aq}
\&  # /cats/lol  \-> {controller => \*(Aqcats\*(Aq, action => \*(Aqdefault\*(Aq}
\&  my $cats = $r\->any(\*(Aq/cats\*(Aq)\->to(controller => \*(Aqcats\*(Aq, action => \*(Aqdefault\*(Aq);
\&  $cats\->get(\*(Aq/\*(Aq)\->to(action => \*(Aqindex\*(Aq);
\&  $cats\->get(\*(Aq/nyan\*(Aq)\->to(action => \*(Aqnyan\*(Aq);
\&  $cats\->get(\*(Aq/lol\*(Aq);
.Ve
.PP
With a few common prefixes you can also greatly improve the routing performance
of applications with many routes, because children are only tried if the prefix
matched first.
.SS "Special stash values"
.IX Subsection "Special stash values"
When the dispatcher sees \f(CW\*(C`controller\*(C'\fR and \f(CW\*(C`action\*(C'\fR values in the stash it
will always try to turn them into a class and method to dispatch to. The
\&\f(CW\*(C`controller\*(C'\fR value gets converted from \f(CW\*(C`snake_case\*(C'\fR to \f(CW\*(C`CamelCase\*(C'\fR using
\&\*(L"camelize\*(R" in Mojo::Util and appended to one or more namespaces, defaulting to
a controller namespace based on the application class (\f(CW\*(C`MyApp::Controller\*(C'\fR),
as well as the bare application class (\f(CW\*(C`MyApp\*(C'\fR), and these namespaces are
searched in that order. The action value is not changed at all, so both values
are case-sensitive.
.PP
.Vb 3
\&  # Application
\&  package MyApp;
\&  use Mojo::Base \*(AqMojolicious\*(Aq;
\&
\&  sub startup {
\&    my $self = shift;
\&
\&    # /bye \-> MyApp::Controller::Foo\->bye
\&    $self\->routes\->get(\*(Aq/bye\*(Aq)\->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbye\*(Aq);
\&  }
\&
\&  1;
\&
\&  # Controller
\&  package MyApp::Controller::Foo;
\&  use Mojo::Base \*(AqMojolicious::Controller\*(Aq;
\&
\&  # Action
\&  sub bye {
\&    my $self = shift;
\&
\&    # Render response
\&    $self\->render(text => \*(AqGood bye.\*(Aq);
\&  }
\&
\&  1;
.Ve
.PP
Controller classes are perfect for organizing code in larger projects. There
are more dispatch strategies, but because controllers are the most commonly
used ones they also got a special shortcut in the form of \f(CW\*(C`controller#action\*(C'\fR.
.PP
.Vb 2
\&  # /bye \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbye\*(Aq, mymessage => \*(AqBye\*(Aq}
\&  $r\->get(\*(Aq/bye\*(Aq)\->to(\*(Aqfoo#bye\*(Aq, mymessage => \*(AqBye\*(Aq);
.Ve
.PP
During camelization \f(CW\*(C`\-\*(C'\fR characters get replaced with \f(CW\*(C`::\*(C'\fR, this allows
multi-level \f(CW\*(C`controller\*(C'\fR hierarchies.
.PP
.Vb 2
\&  # / \-> MyApp::Controller::Foo::Bar\->hi
\&  $r\->get(\*(Aq/\*(Aq)\->to(\*(Aqfoo\-bar#hi\*(Aq);
.Ve
.PP
You can also just specify the \f(CW\*(C`controller\*(C'\fR in CamelCase form instead of
snake_case.
.PP
.Vb 2
\&  # / \-> MyApp::Controller::Foo::Bar\->hi
\&  $r\->get(\*(Aq/\*(Aq)\->to(\*(AqFoo::Bar#hi\*(Aq);
.Ve
.PP
For security reasons the dispatcher will always check if the \f(CW\*(C`controller\*(C'\fR is
actually a subclass of Mojolicious::Controller or Mojo before dispatching
to it.
.SS "Namespaces"
.IX Subsection "Namespaces"
You can use the \f(CW\*(C`namespace\*(C'\fR stash value to change the namespace of a whole
route with all its children.
.PP
.Vb 3
\&  # /bye \-> MyApp::MyController::Foo::Bar\->bye
\&  $r\->get(\*(Aq/bye\*(Aq)
\&    \->to(namespace => \*(AqMyApp::MyController::Foo::Bar\*(Aq, action => \*(Aqbye\*(Aq);
.Ve
.PP
The \f(CW\*(C`controller\*(C'\fR is always converted from \f(CW\*(C`snake_case\*(C'\fR to \f(CW\*(C`CamelCase\*(C'\fR with
\&\*(L"camelize\*(R" in Mojo::Util, and then appended to this \f(CW\*(C`namespace\*(C'\fR.
.PP
.Vb 2
\&  # /bye \-> MyApp::MyController::Foo::Bar\->bye
\&  $r\->get(\*(Aq/bye\*(Aq)\->to(\*(Aqfoo\-bar#bye\*(Aq, namespace => \*(AqMyApp::MyController\*(Aq);
\&
\&  # /hey \-> MyApp::MyController::Foo::Bar\->hey
\&  $r\->get(\*(Aq/hey\*(Aq)\->to(\*(AqFoo::Bar#hey\*(Aq, namespace => \*(AqMyApp::MyController\*(Aq);
.Ve
.PP
You can also change the default namespaces for all routes in the application
with the router attribute \*(L"namespaces\*(R" in Mojolicious::Routes, which usually
defaults to a namespace based on the application class (\f(CW\*(C`MyApp::Controller\*(C'\fR),
as well as the bare application class (\f(CW\*(C`MyApp\*(C'\fR).
.PP
.Vb 1
\&  $r\->namespaces([\*(AqMyApp::MyController\*(Aq]);
.Ve
.SS "Route to callback"
.IX Subsection "Route to callback"
The \f(CW\*(C`cb\*(C'\fR stash value, which won't be inherited by nested routes, can be used
to bypass controllers and execute a callback instead.
.PP
.Vb 4
\&  $r\->get(\*(Aq/bye\*(Aq)\->to(cb => sub {
\&    my $c = shift;
\&    $c\->render(text => \*(AqGood bye.\*(Aq);
\&  });
.Ve
.PP
But just like in Mojolicious::Lite you can also pass the callback directly,
which usually looks much better.
.PP
.Vb 4
\&  $r\->get(\*(Aq/bye\*(Aq => sub {
\&    my $c = shift;
\&    $c\->render(text => \*(AqGood bye.\*(Aq);
\&  });
.Ve
.SS "Named routes"
.IX Subsection "Named routes"
Naming your routes will allow backreferencing in many methods and helpers
throughout the whole framework, most of which internally rely on
\&\*(L"url_for\*(R" in Mojolicious::Controller for this.
.PP
.Vb 2
\&  # /foo/marcus \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, user => \*(Aqmarcus\*(Aq}
\&  $r\->get(\*(Aq/foo/:user\*(Aq)\->to(\*(Aqfoo#bar\*(Aq)\->name(\*(Aqbaz\*(Aq);
\&
\&  # Generate URL "/foo/marcus" for route "baz"
\&  my $url = $c\->url_for(\*(Aqbaz\*(Aq);
\&
\&  # Generate URL "/foo/jan" for route "baz"
\&  my $url = $c\->url_for(\*(Aqbaz\*(Aq, user => \*(Aqjan\*(Aq);
\&
\&  # Generate URL "http://127.0.0.1:3000/foo/jan" for route "baz"
\&  my $url = $c\->url_for(\*(Aqbaz\*(Aq, user => \*(Aqjan\*(Aq)\->to_abs;
.Ve
.PP
You can assign a name with \*(L"name\*(R" in Mojolicious::Routes::Route, or let the
router generate one automatically, which would be equal to the route itself
without non-word characters, custom names have a higher precedence though.
.PP
.Vb 2
\&  # /foo/bar ("foobar")
\&  $r\->get(\*(Aq/foo/bar\*(Aq)\->to(\*(Aqtest#stuff\*(Aq);
\&
\&  # Generate URL "/foo/bar"
\&  my $url = $c\->url_for(\*(Aqfoobar\*(Aq);
.Ve
.PP
To refer to the current route you can use the reserved name \f(CW\*(C`current\*(C'\fR or no
name at all.
.PP
.Vb 3
\&  # Generate URL for current route
\&  my $url = $c\->url_for(\*(Aqcurrent\*(Aq);
\&  my $url = $c\->url_for;
.Ve
.PP
To check or get the name of the current route you can use the helper
\&\*(L"current_route\*(R" in Mojolicious::Plugin::DefaultHelpers.
.PP
.Vb 2
\&  # Name for current route
\&  my $name = $c\->current_route;
\&
\&  # Check route name in code shared by multiple routes
\&  $c\->stash(button => \*(Aqgreen\*(Aq) if $c\->current_route(\*(Aqlogin\*(Aq);
.Ve
.SS "Optional placeholders"
.IX Subsection "Optional placeholders"
Extracted placeholder values will simply redefine older stash values if they
already exist.
.PP
.Vb 3
\&  # /bye \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, mymessage => \*(Aqbye\*(Aq}
\&  # /hey \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, mymessage => \*(Aqhey\*(Aq}
\&  $r\->get(\*(Aq/:mymessage\*(Aq)\->to(\*(Aqfoo#bar\*(Aq, mymessage => \*(Aqhi\*(Aq);
.Ve
.PP
One more interesting effect, a placeholder automatically becomes optional if
there is already a stash value of the same name present, this works similar to
the regular expression \f(CW\*(C`([^/.]+)?\*(C'\fR.
.PP
.Vb 2
\&  # / \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, mymessage => \*(Aqhi\*(Aq}
\&  $r\->get(\*(Aq/:mymessage\*(Aq)\->to(\*(Aqfoo#bar\*(Aq, mymessage => \*(Aqhi\*(Aq);
\&
\&  # /test/123     \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, mymessage => \*(Aqhi\*(Aq}
\&  # /test/bye/123 \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, mymessage => \*(Aqbye\*(Aq}
\&  $r\->get(\*(Aq/test/:mymessage/123\*(Aq)\->to(\*(Aqfoo#bar\*(Aq, mymessage => \*(Aqhi\*(Aq);
.Ve
.PP
And if two optional placeholders are only separated by a slash, that slash can
become optional as well.
.PP
.Vb 4
\&  # /           \-> {controller => \*(Aqfoo\*(Aq,   action => \*(Aqbar\*(Aq}
\&  # /users      \-> {controller => \*(Aqusers\*(Aq, action => \*(Aqbar\*(Aq}
\&  # /users/list \-> {controller => \*(Aqusers\*(Aq, action => \*(Aqlist\*(Aq}
\&  $r\->get(\*(Aq/:controller/:action\*(Aq)\->to(\*(Aqfoo#bar\*(Aq);
.Ve
.PP
Special stash values like \f(CW\*(C`controller\*(C'\fR and \f(CW\*(C`action\*(C'\fR can also be placeholders,
which is very convenient especially during development, but should only be used
very carefully, because every controller method becomes a potential route. All
uppercase methods as well as those starting with an underscore are
automatically hidden from the router and you can use
\&\*(L"hide\*(R" in Mojolicious::Routes to add additional ones.
.PP
.Vb 2
\&  # Hide "create" method in all controllers
\&  $r\->hide(\*(Aqcreate\*(Aq);
.Ve
.PP
This has already been done for all attributes and methods from
Mojolicious::Controller.
.SS "Restrictive placeholders"
.IX Subsection "Restrictive placeholders"
A very easy way to make placeholders more restrictive are alternatives, you
just make a list of possible values, which then work similar to the regular
expression \f(CW\*(C`(bender|leela)\*(C'\fR.
.PP
.Vb 4
\&  # /fry    \-> undef
\&  # /bender \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, name => \*(Aqbender\*(Aq}
\&  # /leela  \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, name => \*(Aqleela\*(Aq}
\&  $r\->get(\*(Aq/:name\*(Aq => [name => [\*(Aqbender\*(Aq, \*(Aqleela\*(Aq]])\->to(\*(Aqfoo#bar\*(Aq);
.Ve
.PP
You can also adjust the regular expressions behind placeholders directly, just
make sure not to use \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR or capturing groups \f(CW\*(C`(...)\*(C'\fR, because
placeholders become part of a larger regular expression internally,
non-capturing groups \f(CW\*(C`(?:...)\*(C'\fR are fine though.
.PP
.Vb 3
\&  # /23   \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, number => 23}
\&  # /test \-> undef
\&  $r\->get(\*(Aq/:number\*(Aq => [number => qr/\ed+/])\->to(\*(Aqfoo#bar\*(Aq);
\&
\&  # /23   \-> undef
\&  # /test \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, name => \*(Aqtest\*(Aq}
\&  $r\->get(\*(Aq/:name\*(Aq => [name => qr/[a\-zA\-Z]+/])\->to(\*(Aqfoo#bar\*(Aq);
.Ve
.PP
This way you get easily readable routes and the raw power of regular
expressions.
.SS "Introspection"
.IX Subsection "Introspection"
The command Mojolicious::Command::routes can be used from the command line
to list all available routes together with names and underlying regular
expressions.
.PP
.Vb 5
\&  $ ./myapp.pl routes \-v
\&  /foo/:name  ....  POST  fooname  ^/foo/([^/.]+)/?(?:\e.([^/]+))?$
\&  /bar        ..U.  *     bar      ^/bar
\&    +/baz     ...W  GET   baz      ^/baz/?(?:\e.([^/]+))?$
\&  /yada       ....  *     yada     ^/yada/?(?:\e.([^/]+))?$
.Ve
.SS "Under"
.IX Subsection "Under"
To share code with multiple nested routes you can use
\&\*(L"under\*(R" in Mojolicious::Routes::Route, because unlike normal nested routes, the
routes generated with it have their own intermediate destination and result in
additional dispatch cycles when they match.
.PP
.Vb 5
\&  # /foo     \-> undef
\&  # /foo/bar \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbaz\*(Aq}
\&  #             {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq}
\&  my $foo = $r\->under(\*(Aq/foo\*(Aq)\->to(\*(Aqfoo#baz\*(Aq);
\&  $foo\->get(\*(Aq/bar\*(Aq)\->to(\*(Aq#bar\*(Aq);
.Ve
.PP
The actual action code for this destination needs to return a true value or the
dispatch chain will be broken, this can be a very powerful tool for
authentication.
.PP
.Vb 4
\&  # /blackjack \-> {cb => sub {...}}
\&  #               {controller => \*(Aqhideout\*(Aq, action => \*(Aqblackjack\*(Aq}
\&  my $auth = $r\->under(\*(Aq/\*(Aq => sub {
\&    my $c = shift;
\&
\&    # Authenticated
\&    return 1 if $c\->req\->headers\->header(\*(AqX\-Bender\*(Aq);
\&
\&    # Not authenticated
\&    $c\->render(text => "You\*(Aqre not Bender.", status => 401);
\&    return undef;
\&  });
\&  $auth\->get(\*(Aq/blackjack\*(Aq)\->to(\*(Aqhideout#blackjack\*(Aq);
.Ve
.PP
Broken dispatch chains can be continued by calling the method
\&\*(L"continue\*(R" in Mojolicious::Controller, this allows for example, non-blocking
operations to finish before reaching the next dispatch cycle.
.PP
.Vb 2
\&  my $maybe = $r\->under(\*(Aq/maybe\*(Aq => sub {
\&    my $c = shift;
\&
\&    # Wait 3 seconds and then give visitors a 50% chance to continue
\&    Mojo::IOLoop\->timer(3 => sub {
\&
\&      # Loser
\&      return $c\->render(text => \*(AqNo luck.\*(Aq) unless int rand 2;
\&
\&      # Winner
\&      $c\->continue;
\&    });
\&
\&    return undef;
\&  });
\&  $maybe\->get(\*(Aq/\*(Aq)\->to(\*(Aqmaybe#winner\*(Aq);
.Ve
.PP
Every destination is just a snapshot of the stash at the time the route
matched, and only the \f(CW\*(C`format\*(C'\fR value is shared by all of them. For a little
more power you can introspect the preceding and succeeding destinations with
\&\*(L"match\*(R" in Mojolicious::Controller.
.PP
.Vb 2
\&  # Action of the fourth dispatch cycle
\&  my $action = $c\->match\->stack\->[3]{action};
.Ve
.SS "Formats"
.IX Subsection "Formats"
File extensions like \f(CW\*(C`.html\*(C'\fR and \f(CW\*(C`.txt\*(C'\fR at the end of a route are
automatically detected and stored in the stash value \f(CW\*(C`format\*(C'\fR.
.PP
.Vb 4
\&  # /foo      \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq}
\&  # /foo.html \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, format => \*(Aqhtml\*(Aq}
\&  # /foo.txt  \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, format => \*(Aqtxt\*(Aq}
\&  $r\->get(\*(Aq/foo\*(Aq)\->to(\*(Aqfoo#bar\*(Aq);
.Ve
.PP
This for example, allows multiple templates in different formats to share the
same action code. Restrictive placeholders can also be used to limit the
allowed formats.
.PP
.Vb 4
\&  # /foo.txt \-> undef
\&  # /foo.rss \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, format => \*(Aqrss\*(Aq}
\&  # /foo.xml \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, format => \*(Aqxml\*(Aq}
\&  $r\->get(\*(Aq/foo\*(Aq => [format => [\*(Aqrss\*(Aq, \*(Aqxml\*(Aq]])\->to(\*(Aqfoo#bar\*(Aq);
.Ve
.PP
A \f(CW\*(C`format\*(C'\fR value can also be passed to \*(L"url_for\*(R" in Mojolicious::Controller.
.PP
.Vb 2
\&  # /foo/bar.txt \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq, format => \*(Aqtxt\*(Aq}
\&  $r\->get(\*(Aq/foo/:action\*(Aq)\->to(\*(Aqfoo#\*(Aq)\->name(\*(Aqbaz\*(Aq);
\&
\&  # Generate URL "/foo/bar.txt" for route "baz"
\&  my $url = $c\->url_for(\*(Aqbaz\*(Aq, action => \*(Aqbar\*(Aq, format => \*(Aqtxt\*(Aq);
.Ve
.PP
Or you can just disable format detection with a special type of restrictive
placeholder, which gets inherited by nested routes, and then re-enable it on
demand.
.PP
.Vb 3
\&  # /foo      \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq}
\&  # /foo.html \-> undef
\&  $r\->get(\*(Aq/foo\*(Aq => [format => 0])\->to(\*(Aqfoo#bar\*(Aq);
\&
\&  # /foo      \-> {controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq}
\&  # /foo.html \-> undef
\&  # /baz      \-> undef
\&  # /baz.txt  \-> {controller => \*(Aqbaz\*(Aq, action => \*(Aqyada\*(Aq, format => \*(Aqtxt\*(Aq}
\&  # /baz.html \-> {controller => \*(Aqbaz\*(Aq, action => \*(Aqyada\*(Aq, format => \*(Aqhtml\*(Aq}
\&  # /baz.xml  \-> undef
\&  my $inactive = $r\->under([format => 0]);
\&  $inactive\->get(\*(Aq/foo\*(Aq)\->to(\*(Aqfoo#bar\*(Aq);
\&  $inactive\->get(\*(Aq/baz\*(Aq => [format => [\*(Aqtxt\*(Aq, \*(Aqhtml\*(Aq]])\->to(\*(Aqbaz#yada\*(Aq);
.Ve
.SS "WebSockets"
.IX Subsection "WebSockets"
With the method \*(L"websocket\*(R" in Mojolicious::Routes::Route you can restrict
access to WebSocket handshakes, which are normal \f(CW\*(C`GET\*(C'\fR requests with some
additional information.
.PP
.Vb 2
\&  # /echo (WebSocket handshake)
\&  $r\->websocket(\*(Aq/echo\*(Aq)\->to(\*(Aqfoo#echo\*(Aq);
\&
\&  # Controller
\&  package MyApp::Controller::Foo;
\&  use Mojo::Base \*(AqMojolicious::Controller\*(Aq;
\&
\&  # Action
\&  sub echo {
\&    my $self = shift;
\&    $self\->on(message => sub {
\&      my ($self, $msg) = @_;
\&      $self\->send("echo: $msg");
\&    });
\&  }
\&
\&  1;
.Ve
.PP
The connection gets established when you respond to the WebSocket handshake
request with a \f(CW101\fR response status, which happens automatically if you
subscribe to an event with \*(L"on\*(R" in Mojolicious::Controller or send a message
with \*(L"send\*(R" in Mojolicious::Controller right away.
.PP
.Vb 7
\&  GET /echo HTTP/1.1
\&  Host: mojolicious.org
\&  User\-Agent: Mojolicious (Perl)
\&  Connection: Upgrade
\&  Upgrade: websocket
\&  Sec\-WebSocket\-Key: IDM3ODE4NDk2MjA1OTcxOQ==
\&  Sec\-WebSocket\-Version: 13
\&
\&  HTTP/1.1 101 Switching Protocols
\&  Server: Mojolicious (Perl)
\&  Date: Tue, 03 Feb 2015 17:08:24 GMT
\&  Connection: Upgrade
\&  Upgrade: websocket
\&  Sec\-WebSocket\-Accept: SWsp5N2iNxPbHlcOTIw8ERvyVPY=
.Ve
.SS "Catch-all route"
.IX Subsection "Catch-all route"
Since routes match in the order in which they were defined, you can catch all
requests that did not match in your last route with an optional wildcard
placeholder.
.PP
.Vb 6
\&  # * /*
\&  $r\->any(\*(Aq/*whatever\*(Aq => {whatever => \*(Aq\*(Aq} => sub {
\&    my $c        = shift;
\&    my $whatever = $c\->param(\*(Aqwhatever\*(Aq);
\&    $c\->render(text => "/$whatever did not match.", status => 404);
\&  });
.Ve
.SS "Conditions"
.IX Subsection "Conditions"
Conditions such as \f(CW\*(C`headers\*(C'\fR, \f(CW\*(C`agent\*(C'\fR and \f(CW\*(C`host\*(C'\fR from
Mojolicious::Plugin::HeaderCondition can be applied to any route with the
method \*(L"over\*(R" in Mojolicious::Routes::Route, and allow even more powerful route
constructs.
.PP
.Vb 2
\&  # / (Origin: http://perl.org)
\&  $r\->get(\*(Aq/\*(Aq)\->over(headers => {Origin => qr/perl\e.org/})\->to(\*(Aqfoo#bar\*(Aq);
\&
\&  # / (Firefox)
\&  $r\->get(\*(Aq/\*(Aq)\->over(agent => qr/Firefox/)\->to(\*(Aqbrowser\-test#firefox\*(Aq);
\&
\&  # / (Internet Explorer)
\&  $r\->get(\*(Aq/\*(Aq)\->over(agent => qr/Internet Explorer/)\->to(\*(Aqbrowser\-test#ie\*(Aq);
\&
\&  # http://mojolicious.org/perldoc
\&  $r\->get(\*(Aq/perldoc\*(Aq)\->over(host => \*(Aqmojolicious.org\*(Aq)\->to(\*(Aqperldoc#index\*(Aq);
.Ve
.PP
Just be aware that conditions are too complex for the routing cache, which
normally speeds up recurring requests, and can therefore reduce performance.
.SS "Hooks"
.IX Subsection "Hooks"
Hooks operate outside the routing system and allow you to extend the framework
itself by sharing code with all requests indiscriminately through
\&\*(L"hook\*(R" in Mojolicious, which makes them a very powerful tool especially for
plugins.
.PP
.Vb 3
\&  # Application
\&  package MyApp;
\&  use Mojo::Base \*(AqMojolicious\*(Aq;
\&
\&  sub startup {
\&    my $self = shift;
\&
\&    # Check all requests for a "/test" prefix
\&    $self\->hook(before_dispatch => sub {
\&      my $c = shift;
\&      $c\->render(text => \*(AqThis request did not reach the router.\*(Aq)
\&        if $c\->req\->url\->path\->contains(\*(Aq/test\*(Aq);
\&    });
\&
\&    # These will not be reached if the hook above renders a response
\&    my $r = $self\->routes;
\&    $r\->get(\*(Aq/welcome\*(Aq)\->to(\*(Aqfoo#welcome\*(Aq);
\&    $r\->post(\*(Aq/bye\*(Aq)\->to(\*(Aqfoo#bye\*(Aq);
\&  }
\&
\&  1;
.Ve
.PP
Post-processing the response to add or remove headers is a very common use.
.PP
.Vb 5
\&  # Make sure static files are cached
\&  $app\->hook(after_static => sub {
\&    my $c = shift;
\&    $c\->res\->headers\->cache_control(\*(Aqmax\-age=3600, must\-revalidate\*(Aq);
\&  });
\&
\&  # Remove a default header
\&  $app\->hook(after_dispatch => sub {
\&    my $c = shift;
\&    $c\->res\->headers\->remove(\*(AqServer\*(Aq);
\&  });
.Ve
.PP
Same for pre-processing the request.
.PP
.Vb 6
\&  # Choose template variant based on request headers
\&  $app\->hook(before_dispatch => sub {
\&    my $c = shift;
\&    return unless my $agent = $c\->req\->headers\->user_agent;
\&    $c\->stash(variant => \*(Aqie\*(Aq) if $agent =~ /Internet Explorer/;
\&  });
.Ve
.PP
Or more advanced extensions to add monitoring to your application.
.PP
.Vb 6
\&  # Forward exceptions to a web service
\&  $app\->hook(after_dispatch => sub {
\&    my $c = shift;
\&    return unless my $e = $c\->stash(\*(Aqexception\*(Aq);
\&    $c\->ua\->post(\*(Aqhttps://example.com/bugs\*(Aq => form => {exception => $e});
\&  });
.Ve
.PP
You can even extend much of the core functionality.
.PP
.Vb 6
\&  # Make controller object available to actions as $_
\&  $app\->hook(around_action => sub {
\&    my ($next, $c, $action, $last) = @_;
\&    local $_ = $c;
\&    return $next\->();
\&  });
\&
\&  # Pass route name as argument to actions
\&  $app\->hook(around_action => sub {
\&    my ($next, $c, $action, $last) = @_;
\&    return $c\->$action($c\->current_route);
\&  });
.Ve
.PP
For a full list of available hooks see \*(L"\s-1HOOKS\s0\*(R" in Mojolicious.
.SH "ADVANCED"
.IX Header "ADVANCED"
Less commonly used and more powerful features.
.SS "Shortcuts"
.IX Subsection "Shortcuts"
To make route generation more expressive, you can also add your own shortcuts
with \*(L"add_shortcut\*(R" in Mojolicious::Routes.
.PP
.Vb 3
\&  # Simple "resource" shortcut
\&  $r\->add_shortcut(resource => sub {
\&    my ($r, $name) = @_;
\&
\&    # Prefix for resource
\&    my $resource = $r\->any("/$name")\->to("$name#");
\&
\&    # Render a list of resources
\&    $resource\->get\->to(\*(Aq#index\*(Aq)\->name($name);
\&
\&    # Render a form to create a new resource (submitted to "store")
\&    $resource\->get(\*(Aq/create\*(Aq)\->to(\*(Aq#create\*(Aq)\->name("create_$name");
\&
\&    # Store newly created resource (submitted by "create")
\&    $resource\->post\->to(\*(Aq#store\*(Aq)\->name("store_$name");
\&
\&    # Render a specific resource
\&    $resource\->get(\*(Aq/:id\*(Aq)\->to(\*(Aq#show\*(Aq)\->name("show_$name");
\&
\&    # Render a form to edit a resource (submitted to "update")
\&    $resource\->get(\*(Aq/:id/edit\*(Aq)\->to(\*(Aq#edit\*(Aq)\->name("edit_$name");
\&
\&    # Store updated resource (submitted by "edit")
\&    $resource\->put(\*(Aq/:id\*(Aq)\->to(\*(Aq#update\*(Aq)\->name("update_$name");
\&
\&    # Remove a resource
\&    $resource\->delete(\*(Aq/:id\*(Aq)\->to(\*(Aq#remove\*(Aq)\->name("remove_$name");
\&
\&    return $resource;
\&  });
\&
\&  # GET /users         \-> {controller => \*(Aqusers\*(Aq, action => \*(Aqindex\*(Aq}
\&  # GET /users/create  \-> {controller => \*(Aqusers\*(Aq, action => \*(Aqcreate\*(Aq}
\&  # POST /users        \-> {controller => \*(Aqusers\*(Aq, action => \*(Aqstore\*(Aq}
\&  # GET /users/23      \-> {controller => \*(Aqusers\*(Aq, action => \*(Aqshow\*(Aq, id => 23}
\&  # GET /users/23/edit \-> {controller => \*(Aqusers\*(Aq, action => \*(Aqedit\*(Aq, id => 23}
\&  # PUT /users/23      \-> {controller => \*(Aqusers\*(Aq, action => \*(Aqupdate\*(Aq, id => 23}
\&  # DELETE /users/23   \-> {controller => \*(Aqusers\*(Aq, action => \*(Aqremove\*(Aq, id => 23}
\&  $r\->resource(\*(Aqusers\*(Aq);
.Ve
.SS "Rearranging routes"
.IX Subsection "Rearranging routes"
From application startup until the first request has arrived, all routes can
still be moved around or even removed with methods like
\&\*(L"add_child\*(R" in Mojolicious::Routes::Route and
\&\*(L"remove\*(R" in Mojolicious::Routes::Route.
.PP
.Vb 3
\&  # GET /example/show \-> {controller => \*(Aqexample\*(Aq, action => \*(Aqshow\*(Aq}
\&  my $show = $r\->get(\*(Aq/show\*(Aq)\->to(\*(Aqexample#show\*(Aq);
\&  $r\->any(\*(Aq/example\*(Aq)\->add_child($show);
\&
\&  # Nothing
\&  $r\->get(\*(Aq/secrets/show\*(Aq)\->to(\*(Aqsecrets#show\*(Aq)\->name(\*(Aqshow_secrets\*(Aq);
\&  $r\->find(\*(Aqshow_secrets\*(Aq)\->remove;
.Ve
.PP
Especially for rearranging routes created by plugins this can be very useful,
to find routes by their name you can use \*(L"find\*(R" in Mojolicious::Routes::Route.
.PP
.Vb 5
\&  # GET /example/test \-> {controller => \*(Aqexample\*(Aq, action => \*(Aqtest\*(Aq}
\&  $r\->get(\*(Aq/something/else\*(Aq)\->to(\*(Aqsomething#else\*(Aq)\->name(\*(Aqtest\*(Aq);
\&  my $test = $r\->find(\*(Aqtest\*(Aq);
\&  $test\->pattern\->parse(\*(Aq/example/test\*(Aq);
\&  $test\->pattern\->defaults({controller => \*(Aqexample\*(Aq, action => \*(Aqtest\*(Aq});
.Ve
.PP
Even the route pattern and destination can still be changed with
\&\*(L"parse\*(R" in Mojolicious::Routes::Pattern and
\&\*(L"defaults\*(R" in Mojolicious::Routes::Pattern.
.SS "Adding conditions"
.IX Subsection "Adding conditions"
You can also add your own conditions with the method
\&\*(L"add_condition\*(R" in Mojolicious::Routes. All conditions are basically router
plugins that run every time a new request arrives, and which need to return a
true value for the route to match.
.PP
.Vb 4
\&  # A condition that randomly allows a route to match
\&  $r\->add_condition(
\&    random => sub {
\&      my ($route, $c, $captures, $num) = @_;
\&
\&      # Loser
\&      return undef if int rand $num;
\&
\&      # Winner
\&      return 1;
\&    }
\&  );
\&
\&  # /maybe (25% chance)
\&  $r\->get(\*(Aq/maybe\*(Aq)\->over(random => 4)\->to(\*(Aqfoo#bar\*(Aq);
.Ve
.SS "Condition plugins"
.IX Subsection "Condition plugins"
You can also package your conditions as reusable plugins.
.PP
.Vb 3
\&  # Plugin
\&  package Mojolicious::Plugin::WerewolfCondition;
\&  use Mojo::Base \*(AqMojolicious::Plugin\*(Aq;
\&
\&  use Astro::MoonPhase;
\&
\&  sub register {
\&    my ($self, $app) = @_;
\&
\&    # Add "werewolf" condition
\&    $app\->routes\->add_condition(werewolf => sub {
\&      my ($route, $c, $captures, $days) = @_;
\&
\&      # Keep the werewolves out!
\&      return undef if abs(14 \- (phase(time))[2]) > ($days / 2);
\&
\&      # It\*(Aqs ok, no werewolf
\&      return 1;
\&    });
\&  }
\&
\&  1;
.Ve
.PP
Now just load the plugin and you are ready to use the condition in all your
applications.
.PP
.Vb 3
\&  # Application
\&  package MyApp;
\&  use Mojo::Base \*(AqMojolicious\*(Aq;
\&
\&  sub startup {
\&    my $self = shift;
\&
\&    # Plugin
\&    $self\->plugin(\*(AqWerewolfCondition\*(Aq);
\&
\&    # /hideout (keep them out for 4 days after full moon)
\&    $self\->routes\->get(\*(Aq/hideout\*(Aq)\->over(werewolf => 4)
\&      \->to(controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq);
\&  }
\&
\&  1;
.Ve
.SS "Mount applications"
.IX Subsection "Mount applications"
The easiest way to embed one application into another is
Mojolicious::Plugin::Mount, which allows you to mount whole self-contained
applications under a domain and/or prefix.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Whole application mounted under "/prefix"
\&  plugin Mount => {\*(Aq/prefix\*(Aq => \*(Aq/home/sri/myapp.pl\*(Aq};
\&
\&  # Mount application with subdomain
\&  plugin Mount => {\*(Aqtest.example.com\*(Aq => \*(Aq/home/sri/myapp2.pl\*(Aq};
\&
\&  # Normal route
\&  get \*(Aq/\*(Aq => sub { shift\->render(text => \*(AqHello World!\*(Aq) };
\&
\&  app\->start;
.Ve
.SS "Embed applications"
.IX Subsection "Embed applications"
For a little more power you can also embed applications by using them instead of
a controller. This allows for example, the use of the Mojolicious::Lite
domain specific language in normal Mojolicious controllers.
.PP
.Vb 3
\&  # Controller
\&  package MyApp::Controller::Bar;
\&  use Mojolicious::Lite;
\&
\&  # /hello
\&  get \*(Aq/hello\*(Aq => sub {
\&    my $c    = shift;
\&    my $name = $c\->param(\*(Aqname\*(Aq);
\&    $c\->render(text => "Hello $name.");
\&  };
\&
\&  1;
.Ve
.PP
With the method \*(L"detour\*(R" in Mojolicious::Routes::Route which is very similar to
\&\*(L"to\*(R" in Mojolicious::Routes::Route, you can allow the route to partially match
and use only the remaining path in the embedded application, the base path will
be passed along in the \f(CW\*(C`path\*(C'\fR stash value.
.PP
.Vb 2
\&  # /foo/*
\&  $r\->any(\*(Aq/foo\*(Aq)\->detour(\*(Aqbar#\*(Aq, name => \*(AqMojo\*(Aq);
.Ve
.PP
A minimal embeddable application is nothing more than a subclass of Mojo,
containing a \f(CW\*(C`handler\*(C'\fR method accepting Mojolicious::Controller objects.
.PP
.Vb 2
\&  package MyApp::Controller::Bar;
\&  use Mojo::Base \*(AqMojo\*(Aq;
\&
\&  sub handler {
\&    my ($self, $c) = @_;
\&    $c\->res\->code(200);
\&    my $name = $c\->param(\*(Aqname\*(Aq);
\&    $c\->res\->body("Hello $name.");
\&  }
\&
\&  1;
.Ve
.SS "Application plugins"
.IX Subsection "Application plugins"
You can even package applications as self-contained reusable plugins.
.PP
.Vb 3
\&  # Plugin
\&  package Mojolicious::Plugin::MyEmbeddedApp;
\&  use Mojo::Base \*(AqMojolicious::Plugin\*(Aq;
\&
\&  sub register {
\&    my ($self, $app) = @_;
\&
\&    # Automatically add route
\&    $app\->routes\->any(\*(Aq/foo\*(Aq)\->detour(app => EmbeddedApp::app());
\&  }
\&
\&  package EmbeddedApp;
\&  use Mojolicious::Lite;
\&
\&  get \*(Aq/bar\*(Aq => \*(Aqbar\*(Aq;
\&
\&  1;
\&  _\|_DATA_\|_
\&  @@ bar.html.ep
\&  Hello World!
.Ve
.PP
The \f(CW\*(C`app\*(C'\fR stash value, which won't be inherited by nested routes, can be used
for already instantiated applications. Now just load the plugin and you're
done.
.PP
.Vb 3
\&  # Application
\&  package MyApp;
\&  use Mojo::Base \*(AqMojolicious\*(Aq;
\&
\&  sub startup {
\&    my $self = shift;
\&
\&    # Plugin
\&    $self\->plugin(\*(AqMyEmbeddedApp\*(Aq);
\&  }
\&
\&  1;
.Ve
.SH "MORE"
.IX Header "MORE"
You can continue with Mojolicious::Guides now or take a look at the
Mojolicious wiki <http://github.com/kraih/mojo/wiki>, which contains a lot
more documentation and examples by many different authors.
.SH "SUPPORT"
.IX Header "SUPPORT"
If you have any questions the documentation might not yet answer, don't
hesitate to ask on the
mailing list <http://groups.google.com/group/mojolicious> or the official \s-1IRC\s0
channel \f(CW\*(C`#mojo\*(C'\fR on \f(CW\*(C`irc.perl.org\*(C'\fR
(chat now! <https://chat.mibbit.com/?channel=%23mojo&server=irc.perl.org>).
