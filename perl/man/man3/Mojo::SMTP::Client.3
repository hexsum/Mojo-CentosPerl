.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojo::SMTP::Client 3"
.TH Mojo::SMTP::Client 3 "2016-06-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::SMTP::Client \- non\-blocking SMTP client based on Mojo::IOLoop
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&        # blocking
\&        my $smtp = Mojo::SMTP::Client\->new(address => \*(Aq10.54.17.28\*(Aq, autodie => 1);
\&        $smtp\->send(
\&                from => \*(Aqme@from.org\*(Aq,
\&                to => \*(Aqyou@to.org\*(Aq,
\&                data => join("\er\en", \*(AqFrom: me@from.org\*(Aq,
\&                                     \*(AqTo: you@to.org\*(Aq,
\&                                     \*(AqSubject: Hello world!\*(Aq,
\&                                     \*(Aq\*(Aq,
\&                                     \*(AqThis is my first message!\*(Aq
\&                        ),
\&                quit => 1
\&        );
\&        warn "Sent successfully"; # else will throw exception because of \`autodie\*(Aq
.Ve
.Sp
.Vb 10
\&        # non\-blocking
\&        my $smtp = Mojo::SMTP::Client\->new(address => \*(Aq10.54.17.28\*(Aq);
\&        $smtp\->send(
\&                from => \*(Aqme@from.org\*(Aq,
\&                to => \*(Aqyou@to.org\*(Aq,
\&                data => join("\er\en", \*(AqFrom: me@from.org\*(Aq,
\&                                     \*(AqTo: you@to.org\*(Aq,
\&                                     \*(AqSubject: Hello world!\*(Aq,
\&                                     \*(Aq\*(Aq,
\&                                     \*(AqThis is my first message!\*(Aq
\&                    ),
\&                quit => 1,
\&                sub {
\&                        my ($smtp, $resp) = @_;
\&                        warn $resp\->error ? \*(AqFailed to send: \*(Aq.$resp\->error : \*(AqSent successfully\*(Aq;
\&                        Mojo::IOLoop\->stop;
\&                }
\&        );
\&        
\&        Mojo::IOLoop\->start;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
With \f(CW\*(C`Mojo::SMTP::Client\*(C'\fR you can easily send emails from your Mojolicious application without
blocking of \f(CW\*(C`Mojo::IOLoop\*(C'\fR.
.SH "EVENTS"
.IX Header "EVENTS"
\&\f(CW\*(C`Mojo::SMTP::Client\*(C'\fR inherits all events from Mojo::EventEmitter and can emit the following new ones
.SS "start"
.IX Subsection "start"
.Vb 5
\&        $smtp\->on(start => sub {
\&                my ($smtp) = @_;
\&                # some servers delays first response to prevent SPAM
\&                $smtp\->inactivity_timeout(5*60);
\&        });
.Ve
.PP
Emitted whenever a new connection is about to start.
.SS "response"
.IX Subsection "response"
.Vb 7
\&        $smtp\->on(response => sub {
\&                my ($smtp, $cmd, $resp) = @_;
\&                if ($cmd == Mojo::SMTP::Client::CMD_CONNECT) {
\&                        # and after first response others should be fast enough
\&                        $smtp\->inactivity_timeout(10);
\&                }
\&        });
.Ve
.PP
Emitted for each \s-1SMTP\s0 response from the server. \f(CW$cmd\fR is a command constant for which this
response was sent. \f(CW$resp\fR is Mojo::SMTP::Client::Response object.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
\&\f(CW\*(C`Mojo::SMTP::Client\*(C'\fR implements the following attributes, which you can set in the constructor or get/set later
with object method call
.SS "address"
.IX Subsection "address"
Address of \s-1SMTP\s0 server (ip or domain name). Default is \f(CW\*(C`localhost\*(C'\fR
.SS "port"
.IX Subsection "port"
Port of \s-1SMTP\s0 server. Default is \f(CW25\fR for plain connection and \f(CW465\fR if \s-1TLS\s0 is enabled.
.SS "tls"
.IX Subsection "tls"
Enable \s-1TLS\s0. Should be true if \s-1SMTP\s0 server expects encrypted connection. Default is false.
Proper version of IO::Socket::SSL should be installed for \s-1TLS\s0 support in Mojo::IOLoop::Client,
which you can find with \f(CW\*(C`mojo version\*(C'\fR command.
.SS "tls_ca"
.IX Subsection "tls_ca"
Path to \s-1TLS\s0 certificate authority file. Also activates hostname verification.
.SS "tls_cert"
.IX Subsection "tls_cert"
Path to the \s-1TLS\s0 certificate file.
.SS "tls_key"
.IX Subsection "tls_key"
Path to the \s-1TLS\s0 key file.
.SS "hello"
.IX Subsection "hello"
\&\s-1SMTP\s0 requires that you identify yourself. This option specifies a string to pass as your mail domain.
Default is \f(CW\*(C`localhost.localdomain\*(C'\fR
.SS "connect_timeout"
.IX Subsection "connect_timeout"
Maximum amount of time in seconds establishing a connection may take before getting canceled,
defaults to the value of the \f(CW\*(C`MOJO_CONNECT_TIMEOUT\*(C'\fR environment variable or \f(CW10\fR
.SS "inactivity_timeout"
.IX Subsection "inactivity_timeout"
Maximum amount of time in seconds a connection can be inactive before getting closed,
defaults to the value of the \f(CW\*(C`MOJO_INACTIVITY_TIMEOUT\*(C'\fR environment variable or \f(CW20\fR.
Setting the value to \f(CW0\fR will allow connections to be inactive indefinitely
.SS "ioloop"
.IX Subsection "ioloop"
Event loop object to use for blocking I/O operations, defaults to a Mojo::IOLoop object
.SS "autodie"
.IX Subsection "autodie"
Defines should or not \f(CW\*(C`Mojo::SMTP::Client\*(C'\fR throw exceptions for any type of errors. This only usable for
blocking usage of \f(CW\*(C`Mojo::SMTP::Client\*(C'\fR, because non-blocking one should never die. Throwed
exception will be one of the specified in Mojo::SMTP::Client::Exception. When autodie attribute
has false value you should check \f(CW\*(C`$resp>error\*(C'\fR yourself. Default is false.
.SH "METHODS"
.IX Header "METHODS"
\&\f(CW\*(C`Mojo::SMTP::Client\*(C'\fR inherits all methods from Mojo::EventEmitter and implements the following new ones
.SS "send"
.IX Subsection "send"
.Vb 7
\&        $smtp\->send(
\&                from => $mail_from,
\&                to   => $rcpt_to,
\&                data => $data,
\&                quit => 1,
\&                $nonblocking ? $cb : ()
\&        );
.Ve
.PP
Send specified commands to \s-1SMTP\s0 server. Arguments should be \f(CW\*(C`key => value\*(C'\fR pairs where \f(CW\*(C`key\*(C'\fR is a command 
and \f(CW\*(C`value\*(C'\fR is a value for this command. \f(CW\*(C`send\*(C'\fR understands the following commands:
.IP "hello" 4
.IX Item "hello"
Send greeting to the server. Argument to this command should contain your domain name. Keep in mind, that
\&\f(CW\*(C`Mojo::SMTP::Client\*(C'\fR will automatically send greeting to the server right after connection if you not specified
\&\f(CW\*(C`hello\*(C'\fR as first command for \f(CW\*(C`send\*(C'\fR. \f(CW\*(C`Mojo::SMTP::Client\*(C'\fR first tries \f(CW\*(C`EHLO\*(C'\fR command for greeting and if
server doesn't accept it \f(CW\*(C`Mojo::SMTP::Client\*(C'\fR retries with \f(CW\*(C`HELO\*(C'\fR command.
.Sp
.Vb 1
\&        $smtp\->send(hello => \*(Aqmymail.me\*(Aq);
.Ve
.IP "starttls" 4
.IX Item "starttls"
Upgrades connection from plain to encrypted. Some servers requires this before sending any other commands.
IO::Socket::SSL 0.98+ should be installed for this to work. See also \*(L"tls_ca\*(R", \*(L"tls_cert\*(R", \*(L"tls_key\*(R"
attributes
.Sp
.Vb 2
\&        $smtp\->tls_ca(\*(Aq/etc/ssl/certs/ca\-certificates.crt\*(Aq);
\&        $smtp\->send(starttls => 1);
.Ve
.IP "auth" 4
.IX Item "auth"
Authorize on \s-1SMTP\s0 server. Argument to this command should be reference to a hash with \f(CW\*(C`login\*(C'\fR and \f(CW\*(C`password\*(C'\fR
keys. Only \s-1PLAIN\s0 authorization supported for now. You should authorize only once per session
.Sp
.Vb 1
\&        $smtp\->send(auth => {login => \*(Aqoleg\*(Aq, password => \*(Aqqwerty\*(Aq});
.Ve
.IP "from" 4
.IX Item "from"
From which email this message was sent. Value for this cammand should be a string with email
.Sp
.Vb 1
\&        $smtp\->send(from => \*(Aqroot@cpan.org\*(Aq);
.Ve
.IP "to" 4
.IX Item "to"
To which email(s) this message should be sent. Value for this cammand should be a string with email
or reference to array with email strings (for more than one recipient)
.Sp
.Vb 2
\&        $smtp\->send(to => \*(Aqoleg@cpan.org\*(Aq);
\&        $smtp\->send(to => [\*(Aqoleg@cpan.org\*(Aq, \*(Aqdo_not_reply@cpantesters.org\*(Aq]);
.Ve
.IP "reset" 4
.IX Item "reset"
After this command server should forget about any started mail transaction and reset it status as it was after response to \f(CW\*(C`EHLO\*(C'\fR/\f(CW\*(C`HELO\*(C'\fR.
Note: transaction considered started after \f(CW\*(C`MAIL FROM\*(C'\fR (\f(CW\*(C`from\*(C'\fR) command.
.Sp
.Vb 1
\&        $smtp\->send(reset => 1);
.Ve
.IP "data" 4
.IX Item "data"
Email body to be sent. Value for this command should be a string (or reference to a string) with email body or reference to subroutine
each call of which should return some chunk of the email as string (or reference to a string) and empty string (or reference to empty string)
at the end (useful to send big emails in memory-efficient way)
.Sp
.Vb 2
\&        $smtp\->send(data => "Subject: This is my first message\er\en\er\enSent from Mojolicious app");
\&        $smtp\->send(data => sub { sysread(DATA, my $buf, 1024); $buf });
.Ve
.IP "quit" 4
.IX Item "quit"
Send \f(CW\*(C`QUIT\*(C'\fR command to \s-1SMTP\s0 server which will close the connection. So for the next use of this server connection will be
reestablished. If you want to send several emails with this server it will be more efficient to not quit
the connection until last email will be sent.
.PP
For non-blocking usage last argument to \f(CW\*(C`send\*(C'\fR should be reference to subroutine which will be called when result will
be available. Subroutine arguments will be \f(CW\*(C`($smtp, $resp)\*(C'\fR. Where \f(CW$resp\fR is object of Mojo::SMTP::Client::Response class.
First you should check \f(CW\*(C`$resp\->error\*(C'\fR \- if it has true value this means that it was error somewhere while sending.
If \f(CW\*(C`error\*(C'\fR has false value you can get code and message for response to last command with \f(CW\*(C`$resp\->code\*(C'\fR (number) and
\&\f(CW\*(C`$resp\->message\*(C'\fR (string).
.PP
For blocking usage \f(CW$resp\fR will be returned as result of \f(CW\*(C`$smtp\->send\*(C'\fR call. \f(CW$resp\fR is the same as for
non-blocking result. If \*(L"autodie\*(R" attribute has true value \f(CW\*(C`send\*(C'\fR will throw an exception on any error.
Which will be one of \f(CW\*(C`Mojo::SMTP::Client::Exception::*\*(C'\fR.
.PP
\&\fBNote\fR. For \s-1SMTP\s0 protocol it is important to send commands in certain order. Also \f(CW\*(C`send\*(C'\fR will send all commands in order you are
specified. So, it is important to pass arguments to \f(CW\*(C`send\*(C'\fR in right order. For basic usage this will always be:
\&\f(CW\*(C`from \-> to \-> data \-> quit\*(C'\fR. You should also know that it is absolutely correct to specify several non-unique commands.
For example you can send several emails with one \f(CW\*(C`send\*(C'\fR call:
.PP
.Vb 9
\&        $smtp\->send(
\&                from => \*(Aqsomeone@somewhere.com\*(Aq,
\&                to   => \*(Aqsomebody@somewhere.net\*(Aq,
\&                data => $mail_1,
\&                from => \*(Aqfrodo@somewhere.com\*(Aq,
\&                to   => \*(Aqgarry@somewhere.net\*(Aq,
\&                data => $mail_2,
\&                quit => 1
\&        );
.Ve
.PP
\&\fBNote\fR. Connection to \s-1SMTP\s0 server will be made on first \f(CW\*(C`send\*(C'\fR or for each \f(CW\*(C`send\*(C'\fR when socket connection not already estabilished
(was closed by \f(CW\*(C`QUIT\*(C'\fR command or errors in the stream). It is error to make several simultaneous non-blocking \f(CW\*(C`send\*(C'\fR calls on the
same \f(CW\*(C`Mojo::SMTP::Client\*(C'\fR, because each client has one global stream per client. So, you need to create several
clients to make simultaneous sending.
.SS "prepend_cmd"
.IX Subsection "prepend_cmd"
.Vb 1
\&        $smtp\->prepend_cmd(reset => 1, starttls => 1);
.Ve
.PP
Prepend specified commands to the queue, so the next command sent to the server will be the first you specified in \f(CW\*(C`prepend_cmd\*(C'\fR.
You can prepend commands only when sending already in progress and there are commands in the queue. So, the most common place to call
\&\f(CW\*(C`prepend_cmd\*(C'\fR is inside \f(CW\*(C`response\*(C'\fR event handler. For example this is how we can say \*(L"start \s-1SSL\s0 session if server supports it\*(R":
.PP
.Vb 12
\&        $smtp\->on(response => sub {
\&                my ($smtp, $cmd, $resp) = @_;
\&                if ($cmd == Mojo::SMTP::Client::CMD_EHLO && $resp\->message =~ /STARTTLS/i) {
\&                        $smtp\->prepend_cmd(starttls => 1);
\&                }
\&        });
\&        $smtp\->send(
\&                from => $from,
\&                to   => $to,
\&                data => $data,
\&                quit => 1
\&        );
.Ve
.PP
\&\f(CW\*(C`prepend_cmd\*(C'\fR accepts same commands as \*(L"send\*(R".
.SH "CONSTANTS"
.IX Header "CONSTANTS"
\&\f(CW\*(C`Mojo::SMTP::Client\*(C'\fR has this non-importable constants
.PP
.Vb 11
\&        CMD_CONNECT  # client connected to SMTP server
\&        CMD_EHLO     # client sent EHLO command
\&        CMD_HELO     # client sent HELO command
\&        CMD_STARTTLS # client sent STARTTLS command
\&        CMD_AUTH     # client sent AUTH command
\&        CMD_FROM     # client sent MAIL FROM command
\&        CMD_TO       # client sent RCPT TO command
\&        CMD_DATA     # client sent DATA command
\&        CMD_DATA_END # client sent . command
\&        CMD_RESET    # client sent RSET command
\&        CMD_QUIT     # client sent QUIT command
.Ve
.SH "VARIABLES"
.IX Header "VARIABLES"
\&\f(CW\*(C`Mojo::SMTP::Client\*(C'\fR has this non-importable variables
.ie n .IP "%CMD" 4
.el .IP "\f(CW%CMD\fR" 4
.IX Item "%CMD"
Get human readable command by it constant
.Sp
.Vb 1
\&        print $Mojo::SMTP::Client::CMD{ Mojo::SMTP::Client::CMD_EHLO };
.Ve
.SH "COOKBOOK"
.IX Header "COOKBOOK"
.SS "How to send simple \s-1ASCII\s0 message"
.IX Subsection "How to send simple ASCII message"
\&\s-1ASCII\s0 message is simple enough, so you can generate it by hand
.PP
.Vb 10
\&        $smtp\->send(
\&                from => \*(Aqme@home.org\*(Aq,
\&                to   => \*(Aqyou@work.org\*(Aq,
\&                data => join(
\&                        "\er\en",
\&                        \*(AqMIME\-Version: 1.0\*(Aq,
\&                        \*(AqSubject: Subject of the message\*(Aq,
\&                        \*(AqFrom: me@home.org\*(Aq,
\&                        \*(AqTo: you@work.org\*(Aq,
\&                        \*(AqContent\-Type: text/plain; charset=UTF\-8\*(Aq,
\&                        \*(Aq\*(Aq,
\&                        \*(AqText of the message\*(Aq
\&                )
\&        );
.Ve
.PP
However it is not recommended to generate emails by hand if you are not
familar with \s-1MIME\s0 standard. For more convenient approaches see below.
.SS "How to send text message with possible non-ASCII characters"
.IX Subsection "How to send text message with possible non-ASCII characters"
For more convinient way to generate emails we can use some email generators
available on \s-1CPAN\s0. MIME::Lite for example. With such modules we can get
email as a string and send it with \f(CW\*(C`Mojo::SMTP::Client\*(C'\fR
.PP
.Vb 2
\&        use MIME::Lite;
\&        use Encode qw(encode decode);
\&        
\&        my $msg = MIME::Lite\->new(
\&                Type    => \*(Aqtext\*(Aq,
\&                From    => \*(Aqme@home.org\*(Aq,
\&                To      => \*(Aqyou@work.org\*(Aq,
\&                Subject => encode(\*(AqMIME\-Header\*(Aq, decode(\*(Aqutf\-8\*(Aq, \*(AqXX, XX, 5X!\*(Aq)),
\&                Data    => \*(AqNovosibirsk (Russian: XXXXXXXXXXX; IPA: [nXvXsXXXbXirsk]) is the third most populous \*(Aq.
\&                           \*(Aqcity in Russia after Moscow and St. Petersburg and the most populous city in Asian Russia\*(Aq
\&        );
\&        $msg\->attr(\*(Aqcontent\-type.charset\*(Aq => \*(AqUTF\-8\*(Aq);
\&        
\&        $smtp\->send(
\&                from => \*(Aqme@home.org\*(Aq,
\&                to   => \*(Aqyou@work.org\*(Aq,
\&                data => $msg\->as_string
\&        );
.Ve
.SS "How to send message with attachment"
.IX Subsection "How to send message with attachment"
This is also simple with help of MIME::Lite
.PP
.Vb 1
\&        use MIME::Lite;
\&        
\&        my $msg = MIME::Lite\->new(
\&                Type    => \*(Aqmultipart/mixed\*(Aq,
\&                From    => \*(Aqme@home.org\*(Aq,
\&                To      => \*(Aqyou@work.org\*(Aq,
\&                Subject => \*(Aqstatistic for 10.03.2015\*(Aq
\&        );
\&        $msg\->attach(Path => \*(Aq/home/kate/stat/10032015.xlsx\*(Aq, Disposition => \*(Aqattachment\*(Aq, Type => "application/vnd.openxmlformats\-officedocument.spreadsheetml.sheet");
\&        
\&        $smtp\->send(
\&                from => \*(Aqme@home.org\*(Aq,
\&                to   => \*(Aqyou@work.org\*(Aq,
\&                data => $msg\->as_string
\&        );
.Ve
.SS "How to send message with \s-1BIG\s0 attachment"
.IX Subsection "How to send message with BIG attachment"
It will be not cool to get message with 50 mb attachment into memory before sending.
Fortunately with help of MIME::Lite and MIME::Lite::Generator we can generate
our email by small portions. As you remember \f(CW\*(C`data\*(C'\fR command accepts subroutine reference
as argument, so it will be super easy to send our big email in memory-efficient way
.PP
.Vb 1
\&        use MIME::Lite;
\&        
\&        my $msg = MIME::Lite\->new(
\&                Type    => \*(Aqmultipart/mixed\*(Aq,
\&                From    => \*(Aqme@home.org\*(Aq,
\&                To      => \*(Aqyou@work.org\*(Aq,
\&                Subject => \*(Aqmy home video\*(Aq
\&        );
\&        # Note: MIME::Lite will not load this file into memory
\&        $msg\->attach(Path => \*(Aq/home/kate/videos/beach.avi\*(Aq, Disposition => \*(Aqattachment\*(Aq, Type => "video/msvideo");
\&        
\&        my $generator = MIME::Lite::Generator\->new($msg);
\&        
\&        $smtp\->send(
\&                from => \*(Aqme@home.org\*(Aq,
\&                to   => \*(Aqyou@work.org\*(Aq,
\&                data => sub { $generator\->get() }
\&        );
.Ve
.SS "How to send message using public email services like Gmail"
.IX Subsection "How to send message using public email services like Gmail"
Most such services provides access via \s-1SMTP\s0 in addition to web interface, but needs authorization. To protect your
login and password most of them requires to start encrypted session (by upgrading plain connection with \f(CW\*(C`starttls\*(C'\fR
or by initial \f(CW\*(C`tls\*(C'\fR connection). For example Gmail supports both this ways:
.PP
.Vb 11
\&        # make plain connection to port 25
\&        my $smtp = Mojo::SMTP::Client\->new(address => \*(Aqsmtp.gmail.com\*(Aq);
\&        # and upgrade it to TLS with starttls
\&        $smtp\->send(
\&                starttls => 1,
\&                auth => {login => $login, password => $password},
\&                from => $from,
\&                to   => $to,
\&                data => $msg,
\&                quit => 1
\&        );
\&        
\&        # or make initial TLS connection to port 465
\&        my $smtp = Mojo::SMTP::Client\->new(address => \*(Aqsmtp.gmail.com\*(Aq, tls => 1);
\&        # no need to use starttls
\&        $smtp\->send(
\&                auth => {login => $login, password => $password},
\&                from => $from,
\&                to   => $to,
\&                data => $msg,
\&                quit => 1
\&        );
.Ve
.SS "How to send message directly, without using of MTAs such as sendmail, postfix, exim, ..."
.IX Subsection "How to send message directly, without using of MTAs such as sendmail, postfix, exim, ..."
Sometimes it is more suitable to send message directly to \s-1SMTP\s0 server of recipient. For example
if you haven't any \s-1MTA\s0 available or want to check recipient's server responses (e.g. to know is
such user exists on this server [see Mojo::Email::Checker::SMTP]). First you need to know address
of necessary \s-1SMTP\s0 server. We'll get it with help of Net::DNS. Then we'll send it as usual
.PP
.Vb 6
\&        # will use non\-blocking approach in this example
\&        use strict;
\&        use MIME::Lite;
\&        use Net::DNS;
\&        use Mojo::SMTP::Client;
\&        use Mojo::IOLoop;
\&        
\&        use constant TO => \*(Aqoleg@cpan.org\*(Aq;
\&        
\&        my $loop = Mojo::IOLoop\->singleton;
\&        my $resolver = Net::DNS::Resolver\->new();
\&        my ($domain) = TO =~ /@(.+)/;
\&        
\&        # Get MX records
\&        my $sock = $resolver\->bgsend($domain, \*(AqMX\*(Aq);
\&        $loop\->reactor\->io($sock => sub {
\&                my $packet = $resolver\->bgread($sock);
\&                $loop\->reactor\->remove($sock);
\&                
\&                my @mx;
\&                if ($packet) {
\&                        for my $rec ($packet\->answer) {
\&                                push @mx, $rec\->exchange if $rec\->type eq \*(AqMX\*(Aq;
\&                        }
\&                }
\&                
\&                # Will try with first or plain domain name if no mx records found
\&                my $address = @mx ? $mx[0] : $domain;
\&                
\&                my $smtp = Mojo::SMTP::Client\->new(
\&                        address => $address,
\&                        # it is important to properly identify yourself
\&                        hello   => \*(Aqhome.org\*(Aq
\&                );
\&                
\&                my $msg = MIME::Lite\->new(
\&                        Type    => \*(Aqtext\*(Aq,
\&                        From    => \*(Aqme@home.org\*(Aq,
\&                        To      => TO,
\&                        Subject => \*(AqDirect email\*(Aq,
\&                        Data    => \*(AqGet it!\*(Aq
\&                );
\&                
\&                $smtp\->on(response => sub {
\&                        # some debug
\&                        my ($smtp, $cmd, $resp) = @_;
\&                        
\&                        print ">>", $Mojo::SMTP::Client::CMD{$cmd}, "\en";
\&                        print "<<", $resp, "\en";
\&                });
\&                
\&                $smtp\->send(
\&                        from => \*(Aqme@home.org\*(Aq,
\&                        to   => TO,
\&                        data => $msg\->as_string,
\&                        quit => 1,
\&                        sub {
\&                                my ($smtp, $resp) = @_;
\&                                
\&                                warn $resp\->error ? \*(AqFailed to send: \*(Aq.$resp\->error :
\&                                                      \*(AqSent successfully with code: \*(Aq, $resp\->code;
\&                                
\&                                $loop\->stop;
\&                        }
\&                );
\&        });
\&        $loop\->reactor\->watch($sock, 1, 0);
\&        
\&        $loop\->start;
.Ve
.PP
Note: some servers may check your \s-1PTR\s0 record, availability of \s-1SMTP\s0 server
on your domain and so on.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojo::SMTP::Client::Response, Mojo::SMTP::Client::Exception, Mojolicious, Mojo::IOLoop,
\&\s-1RFC5321\s0 (\s-1SMTP\s0) <https://tools.ietf.org/html/rfc5321>, \s-1RFC3207\s0 (\s-1STARTTLS\s0) <https://tools.ietf.org/html/rfc3207>,
\&\s-1RFC4616\s0 (\s-1AUTH\s0 \s-1PLAIN\s0) <https://tools.ietf.org/html/rfc4616>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright Oleg G <oleg@cpan.org>.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
