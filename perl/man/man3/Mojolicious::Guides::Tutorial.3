.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojolicious::Guides::Tutorial 3"
.TH Mojolicious::Guides::Tutorial 3 "2016-09-02" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojolicious::Guides::Tutorial \- Get started with Mojolicious
.SH "TUTORIAL"
.IX Header "TUTORIAL"
A quick example-driven introduction to the wonders of Mojolicious::Lite.
Almost everything you'll learn here also applies to full Mojolicious
applications.
.PP
This is only the first of the Mojolicious::Guides. Other guides delve deeper
into topics like growing a Mojolicious::Lite
prototype into a well-structured Mojolicious application,
routing,
rendering and more. It is highly encouraged
that readers continue on to the remaining guides after reading this one.
.SS "Hello World"
.IX Subsection "Hello World"
A simple Hello World application can look like this, strict, warnings,
utf8 and Perl 5.10 features are automatically enabled and a few
functions imported, when you use
Mojolicious::Lite, turning your script into a full featured web application.
.PP
.Vb 2
\&  #!/usr/bin/env perl
\&  use Mojolicious::Lite;
\&
\&  get \*(Aq/\*(Aq => sub {
\&    my $c = shift;
\&    $c\->render(text => \*(AqHello World!\*(Aq);
\&  };
\&
\&  app\->start;
.Ve
.PP
With Mojolicious::Command::generate::lite_app there is also a helper command
to generate a small example application.
.PP
.Vb 1
\&  $ mojo generate lite_app myapp.pl
.Ve
.SS "Commands"
.IX Subsection "Commands"
Many different commands are automatically
available from the command line. \s-1CGI\s0 and \s-1PSGI\s0 environments can even be
detected and will usually just work without commands.
.PP
.Vb 2
\&  $ ./myapp.pl daemon
\&  Server available at http://127.0.0.1:3000
\&
\&  $ ./myapp.pl daemon \-l http://*:8080
\&  Server available at http://127.0.0.1:8080
\&
\&  $ ./myapp.pl cgi
\&  ...CGI output...
\&
\&  $ ./myapp.pl get /
\&  Hello World!
\&
\&  $ ./myapp.pl
\&  ...List of available commands (or automatically detected environment)...
.Ve
.PP
A call to \*(L"start\*(R" in Mojolicious (\f(CW\*(C`app\->start\*(C'\fR), which starts the command
system, should be the last expression in your application, because its return
value can be significant.
.PP
.Vb 2
\&  # Use @ARGV to pick a command
\&  app\->start;
\&
\&  # Start the "daemon" command
\&  app\->start(\*(Aqdaemon\*(Aq, \*(Aq\-l\*(Aq, \*(Aqhttp://*:8080\*(Aq);
.Ve
.SS "Reloading"
.IX Subsection "Reloading"
Your application will automatically reload itself if you start it with the
morbo development web server, so you don't have to restart the server after
every change.
.PP
.Vb 2
\&  $ morbo ./myapp.pl
\&  Server available at http://127.0.0.1:3000
.Ve
.PP
For more information about how to deploy your application see also
\&\*(L"\s-1DEPLOYMENT\s0\*(R" in Mojolicious::Guides::Cookbook.
.SS "Routes"
.IX Subsection "Routes"
Routes are basically just fancy paths that can contain different kinds of
placeholders and usually lead to an action, if they match the path part of the
request \s-1URL\s0. The first argument passed to all actions (\f(CW$c\fR) is a
Mojolicious::Controller object, containing both the \s-1HTTP\s0 request and
response.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Route leading to an action that renders some text
\&  get \*(Aq/foo\*(Aq => sub {
\&    my $c = shift;
\&    $c\->render(text => \*(AqHello World!\*(Aq);
\&  };
\&
\&  app\->start;
.Ve
.PP
Response content is often generated by actions with
\&\*(L"render\*(R" in Mojolicious::Controller, but more about that later.
.SS "\s-1GET/POST\s0 parameters"
.IX Subsection "GET/POST parameters"
All \f(CW\*(C`GET\*(C'\fR and \f(CW\*(C`POST\*(C'\fR parameters sent with the request are accessible via
\&\*(L"param\*(R" in Mojolicious::Controller.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # /foo?user=sri
\&  get \*(Aq/foo\*(Aq => sub {
\&    my $c    = shift;
\&    my $user = $c\->param(\*(Aquser\*(Aq);
\&    $c\->render(text => "Hello $user.");
\&  };
\&
\&  app\->start;
.Ve
.SS "Stash and templates"
.IX Subsection "Stash and templates"
The \*(L"stash\*(R" in Mojolicious::Controller is used to pass data to templates, which
can be inlined in the \f(CW\*(C`DATA\*(C'\fR section. A few stash values like \f(CW\*(C`template\*(C'\fR,
\&\f(CW\*(C`text\*(C'\fR and \f(CW\*(C`data\*(C'\fR are reserved and will be used by
\&\*(L"render\*(R" in Mojolicious::Controller to decide how a response should be
generated.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Route leading to an action that renders a template
\&  get \*(Aq/foo\*(Aq => sub {
\&    my $c = shift;
\&    $c\->stash(one => 23);
\&    $c\->render(template => \*(Aqmagic\*(Aq, two => 24);
\&  };
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ magic.html.ep
\&  The magic numbers are <%= $one %> and <%= $two %>.
.Ve
.PP
For more information about templates see also
\&\*(L"Embedded Perl\*(R" in Mojolicious::Guides::Rendering.
.SS "\s-1HTTP\s0"
.IX Subsection "HTTP"
\&\*(L"req\*(R" in Mojolicious::Controller and \*(L"res\*(R" in Mojolicious::Controller give you
full access to all \s-1HTTP\s0 features and information.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Access request information
\&  get \*(Aq/agent\*(Aq => sub {
\&    my $c    = shift;
\&    my $host = $c\->req\->url\->to_abs\->host;
\&    my $ua   = $c\->req\->headers\->user_agent;
\&    $c\->render(text => "Request by $ua reached $host.");
\&  };
\&
\&  # Echo the request body and send custom header with response
\&  post \*(Aq/echo\*(Aq => sub {
\&    my $c = shift;
\&    $c\->res\->headers\->header(\*(AqX\-Bender\*(Aq => \*(AqBite my shiny metal ass!\*(Aq);
\&    $c\->render(data => $c\->req\->body);
\&  };
\&
\&  app\->start;
.Ve
.PP
You can test the more advanced examples right from the command line with
Mojolicious::Command::get.
.PP
.Vb 1
\&  $ ./myapp.pl get \-v \-M POST \-c \*(Aqtest\*(Aq /echo
.Ve
.SS "\s-1JSON\s0"
.IX Subsection "JSON"
\&\s-1JSON\s0 is the most commonly used data-interchange format for web services.
Mojolicious loves \s-1JSON\s0 and comes with the possibly fastest pure-Perl
implementation Mojo::JSON built right in, which is accessible through
\&\*(L"json\*(R" in Mojo::Message as well as the reserved stash value \f(CW\*(C`json\*(C'\fR.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Modify the received JSON document and return it
\&  put \*(Aq/reverse\*(Aq => sub {
\&    my $c    = shift;
\&    my $hash = $c\->req\->json;
\&    $hash\->{message} = reverse $hash\->{message};
\&    $c\->render(json => $hash);
\&  };
\&
\&  app\->start;
.Ve
.PP
You can send \s-1JSON\s0 documents from the command line with
Mojolicious::Command::get.
.PP
.Vb 1
\&  $ ./myapp.pl get \-M PUT \-c \*(Aq{"message":"Hello Mojo!"}\*(Aq /reverse
.Ve
.ie n .SS "Built-in ""exception"" and ""not_found"" pages"
.el .SS "Built-in \f(CWexception\fP and \f(CWnot_found\fP pages"
.IX Subsection "Built-in exception and not_found pages"
During development you will encounter these pages whenever you make a mistake,
they are gorgeous and contain a lot of valuable information that will aid you
in debugging your application.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Not found (404)
\&  get \*(Aq/missing\*(Aq => sub { shift\->render(template => \*(Aqdoes_not_exist\*(Aq) };
\&
\&  # Exception (500)
\&  get \*(Aq/dies\*(Aq => sub { die \*(AqIntentional error\*(Aq };
\&
\&  app\->start;
.Ve
.PP
You can even use \s-1CSS\s0 selectors with Mojolicious::Command::get to extract only
the information you're actually interested in.
.PP
.Vb 1
\&  $ ./myapp.pl get /dies \*(Aq#error\*(Aq
.Ve
.PP
And don't worry about revealing too much information on these pages, they are
only available during development, and will be replaced automatically with pages
that don't reveal any sensitive information in a production environment.
.SS "Route names"
.IX Subsection "Route names"
All routes can have a name associated with them, this allows automatic template
detection and backreferencing with \*(L"url_for\*(R" in Mojolicious::Controller, on
which many methods and helpers like
\&\*(L"link_to\*(R" in Mojolicious::Plugin::TagHelpers rely.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Render the template "index.html.ep"
\&  get \*(Aq/\*(Aq => sub {
\&    my $c = shift;
\&    $c\->render;
\&  } => \*(Aqindex\*(Aq;
\&
\&  # Render the template "hello.html.ep"
\&  get \*(Aq/hello\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ index.html.ep
\&  <%= link_to Hello  => \*(Aqhello\*(Aq %>.
\&  <%= link_to Reload => \*(Aqindex\*(Aq %>.
\&
\&  @@ hello.html.ep
\&  Hello World!
.Ve
.PP
Nameless routes get an automatically generated one assigned that is simply
equal to the route itself without non-word characters.
.SS "Layouts"
.IX Subsection "Layouts"
Templates can have layouts too, you just select one with the helper
\&\*(L"layout\*(R" in Mojolicious::Plugin::DefaultHelpers and place the result of the
current template with the helper
\&\*(L"content\*(R" in Mojolicious::Plugin::DefaultHelpers.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  get \*(Aq/with_layout\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ with_layout.html.ep
\&  % title \*(AqGreen\*(Aq;
\&  % layout \*(Aqgreen\*(Aq;
\&  Hello World!
\&
\&  @@ layouts/green.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    <head><title><%= title %></title></head>
\&    <body><%= content %></body>
\&  </html>
.Ve
.PP
The stash or helpers like \*(L"title\*(R" in Mojolicious::Plugin::DefaultHelpers can be
used to pass additional data to the layout.
.SS "Blocks"
.IX Subsection "Blocks"
Template blocks can be used like normal Perl functions and are always delimited
by the \f(CW\*(C`begin\*(C'\fR and \f(CW\*(C`end\*(C'\fR keywords, they are the foundation for many helpers.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  get \*(Aq/with_block\*(Aq => \*(Aqblock\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ block.html.ep
\&  % my $link = begin
\&    % my ($url, $name) = @_;
\&    Try <%= link_to $url => begin %><%= $name %><% end %>.
\&  % end
\&  <!DOCTYPE html>
\&  <html>
\&    <head><title>Sebastians frameworks</title></head>
\&    <body>
\&      %= $link\->(\*(Aqhttp://mojolicious.org\*(Aq, \*(AqMojolicious\*(Aq)
\&      %= $link\->(\*(Aqhttp://catalystframework.org\*(Aq, \*(AqCatalyst\*(Aq)
\&    </body>
\&  </html>
.Ve
.SS "Helpers"
.IX Subsection "Helpers"
Helpers are little functions you can create with the keyword
\&\*(L"helper\*(R" in Mojolicious::Lite and reuse throughout your whole application, from
actions to templates.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # A helper to identify visitors
\&  helper whois => sub {
\&    my $c     = shift;
\&    my $agent = $c\->req\->headers\->user_agent || \*(AqAnonymous\*(Aq;
\&    my $ip    = $c\->tx\->remote_address;
\&    return "$agent ($ip)";
\&  };
\&
\&  # Use helper in action and template
\&  get \*(Aq/secret\*(Aq => sub {
\&    my $c    = shift;
\&    my $user = $c\->whois;
\&    $c\->app\->log\->debug("Request from $user");
\&  };
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ secret.html.ep
\&  We know who you are <%= whois %>.
.Ve
.PP
A list of all built-in ones can be found in
Mojolicious::Plugin::DefaultHelpers and Mojolicious::Plugin::TagHelpers.
.SS "Placeholders"
.IX Subsection "Placeholders"
Route placeholders allow capturing parts of a request path until a \f(CW\*(C`/\*(C'\fR or \f(CW\*(C`.\*(C'\fR
separator occurs, similar to the regular expression \f(CW\*(C`([^/.]+)\*(C'\fR. Results are
accessible via \*(L"stash\*(R" in Mojolicious::Controller and
\&\*(L"param\*(R" in Mojolicious::Controller.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # /foo/test
\&  # /foo/test123
\&  get \*(Aq/foo/:bar\*(Aq => sub {
\&    my $c   = shift;
\&    my $bar = $c\->stash(\*(Aqbar\*(Aq);
\&    $c\->render(text => "Our :bar placeholder matched $bar");
\&  };
\&
\&  # /testsomething/foo
\&  # /test123something/foo
\&  get \*(Aq/(:bar)something/foo\*(Aq => sub {
\&    my $c   = shift;
\&    my $bar = $c\->param(\*(Aqbar\*(Aq);
\&    $c\->render(text => "Our :bar placeholder matched $bar");
\&  };
\&
\&  app\->start;
.Ve
.PP
To separate them from the surrounding text, you can surround your placeholders
with parentheses, which also makes the colon prefix optional.
.SS "Relaxed Placeholders"
.IX Subsection "Relaxed Placeholders"
Relaxed placeholders allow matching of everything until a \f(CW\*(C`/\*(C'\fR occurs, similar
to the regular expression \f(CW\*(C`([^/]+)\*(C'\fR.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # /hello/test
\&  # /hello/test.html
\&  get \*(Aq/hello/#you\*(Aq => \*(Aqgroovy\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ groovy.html.ep
\&  Your name is <%= $you %>.
.Ve
.SS "Wildcard placeholders"
.IX Subsection "Wildcard placeholders"
Wildcard placeholders allow matching absolutely everything, including \f(CW\*(C`/\*(C'\fR and
\&\f(CW\*(C`.\*(C'\fR, similar to the regular expression \f(CW\*(C`(.+)\*(C'\fR.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # /hello/test
\&  # /hello/test123
\&  # /hello/test.123/test/123
\&  get \*(Aq/hello/*you\*(Aq => \*(Aqgroovy\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ groovy.html.ep
\&  Your name is <%= $you %>.
.Ve
.SS "\s-1HTTP\s0 methods"
.IX Subsection "HTTP methods"
Routes can be restricted to specific request methods with different keywords
like \*(L"get\*(R" in Mojolicious::Lite and \*(L"any\*(R" in Mojolicious::Lite.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # GET /hello
\&  get \*(Aq/hello\*(Aq => sub {
\&    my $c = shift;
\&    $c\->render(text => \*(AqHello World!\*(Aq);
\&  };
\&
\&  # PUT /hello
\&  put \*(Aq/hello\*(Aq => sub {
\&    my $c    = shift;
\&    my $size = length $c\->req\->body;
\&    $c\->render(text => "You uploaded $size bytes to /hello.");
\&  };
\&
\&  # GET|POST|PATCH /bye
\&  any [\*(AqGET\*(Aq, \*(AqPOST\*(Aq, \*(AqPATCH\*(Aq] => \*(Aq/bye\*(Aq => sub {
\&    my $c = shift;
\&    $c\->render(text => \*(AqBye World!\*(Aq);
\&  };
\&
\&  # * /whatever
\&  any \*(Aq/whatever\*(Aq => sub {
\&    my $c      = shift;
\&    my $method = $c\->req\->method;
\&    $c\->render(text => "You called /whatever with $method.");
\&  };
\&
\&  app\->start;
.Ve
.SS "Optional placeholders"
.IX Subsection "Optional placeholders"
All placeholders require a value, but by assigning them default values you can
make capturing optional.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # /hello
\&  # /hello/Sara
\&  get \*(Aq/hello/:name\*(Aq => {name => \*(AqSebastian\*(Aq, day => \*(AqMonday\*(Aq} => sub {
\&    my $c = shift;
\&    $c\->render(template => \*(Aqgroovy\*(Aq, format => \*(Aqtxt\*(Aq);
\&  };
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ groovy.txt.ep
\&  My name is <%= $name %> and it is <%= $day %>.
.Ve
.PP
Default values that don't belong to a placeholder simply get merged into the
stash all the time.
.SS "Restrictive placeholders"
.IX Subsection "Restrictive placeholders"
A very easy way to make placeholders more restrictive are alternatives, you just
make a list of possible values.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # /test
\&  # /123
\&  any \*(Aq/:foo\*(Aq => [foo => [\*(Aqtest\*(Aq, \*(Aq123\*(Aq]] => sub {
\&    my $c   = shift;
\&    my $foo = $c\->param(\*(Aqfoo\*(Aq);
\&    $c\->render(text => "Our :foo placeholder matched $foo");
\&  };
\&
\&  app\->start;
.Ve
.PP
All placeholders get compiled to a regular expression internally, this process
can also be customized. Just make sure not to use \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`$\*(C'\fR, or capturing
groups \f(CW\*(C`(...)\*(C'\fR, non-capturing groups \f(CW\*(C`(?:...)\*(C'\fR are fine though.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # /1
\&  # /123
\&  any \*(Aq/:bar\*(Aq => [bar => qr/\ed+/] => sub {
\&    my $c   = shift;
\&    my $bar = $c\->param(\*(Aqbar\*(Aq);
\&    $c\->render(text => "Our :bar placeholder matched $bar");
\&  };
\&
\&  app\->start;
.Ve
.PP
You can take a closer look at all the generated regular expressions with the
command Mojolicious::Command::routes.
.PP
.Vb 1
\&  $ ./myapp.pl routes \-v
.Ve
.SS "Under"
.IX Subsection "Under"
Authentication and code shared between multiple routes can be realized easily
with routes generated by \*(L"under\*(R" in Mojolicious::Lite. All following routes are
only evaluated if the callback returned a true value.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Authenticate based on name parameter
\&  under sub {
\&    my $c = shift;
\&
\&    # Authenticated
\&    my $name = $c\->param(\*(Aqname\*(Aq) || \*(Aq\*(Aq;
\&    return 1 if $name eq \*(AqBender\*(Aq;
\&
\&    # Not authenticated
\&    $c\->render(template => \*(Aqdenied\*(Aq);
\&    return undef;
\&  };
\&
\&  # Only reached when authenticated
\&  get \*(Aq/\*(Aq => \*(Aqindex\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ denied.html.ep
\&  You are not Bender, permission denied.
\&
\&  @@ index.html.ep
\&  Hi Bender.
.Ve
.PP
Prefixing multiple routes is another good use for it.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # /foo
\&  under \*(Aq/foo\*(Aq;
\&
\&  # /foo/bar
\&  get \*(Aq/bar\*(Aq => {text => \*(Aqfoo bar\*(Aq};
\&
\&  # /foo/baz
\&  get \*(Aq/baz\*(Aq => {text => \*(Aqfoo baz\*(Aq};
\&
\&  # / (reset)
\&  under \*(Aq/\*(Aq => {msg => \*(Aqwhatever\*(Aq};
\&
\&  # /bar
\&  get \*(Aq/bar\*(Aq => {inline => \*(Aq<%= $msg %> works\*(Aq};
\&
\&  app\->start;
.Ve
.PP
You can also group related routes with \*(L"group\*(R" in Mojolicious::Lite, which
allows nesting of routes generated with \*(L"under\*(R" in Mojolicious::Lite.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Global logic shared by all routes
\&  under sub {
\&    my $c = shift;
\&    return 1 if $c\->req\->headers\->header(\*(AqX\-Bender\*(Aq);
\&    $c\->render(text => "You\*(Aqre not Bender.");
\&    return undef;
\&  };
\&
\&  # Admin section
\&  group {
\&
\&    # Local logic shared only by routes in this group
\&    under \*(Aq/admin\*(Aq => sub {
\&      my $c = shift;
\&      return 1 if $c\->req\->headers\->header(\*(AqX\-Awesome\*(Aq);
\&      $c\->render(text => "You\*(Aqre not awesome enough.");
\&      return undef;
\&    };
\&
\&    # GET /admin/dashboard
\&    get \*(Aq/dashboard\*(Aq => {text => \*(AqNothing to see here yet.\*(Aq};
\&  };
\&
\&  # GET /welcome
\&  get \*(Aq/welcome\*(Aq => {text => \*(AqHi Bender.\*(Aq};
\&
\&  app\->start;
.Ve
.SS "Formats"
.IX Subsection "Formats"
Formats can be automatically detected from file extensions like \f(CW\*(C`.html\*(C'\fR, they
are used to find the right template and generate the correct \f(CW\*(C`Content\-Type\*(C'\fR
header.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # /detection
\&  # /detection.html
\&  # /detection.txt
\&  get \*(Aq/detection\*(Aq => sub {
\&    my $c = shift;
\&    $c\->render(template => \*(Aqdetected\*(Aq);
\&  };
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ detected.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    <head><title>Detected</title></head>
\&    <body>HTML was detected.</body>
\&  </html>
\&
\&  @@ detected.txt.ep
\&  TXT was detected.
.Ve
.PP
The default format is \f(CW\*(C`html\*(C'\fR, and restrictive placeholders can be used to
limit possible values.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # /hello.json
\&  # /hello.txt
\&  get \*(Aq/hello\*(Aq => [format => [\*(Aqjson\*(Aq, \*(Aqtxt\*(Aq]] => sub {
\&    my $c = shift;
\&    return $c\->render(json => {hello => \*(Aqworld\*(Aq})
\&      if $c\->stash(\*(Aqformat\*(Aq) eq \*(Aqjson\*(Aq;
\&    $c\->render(text => \*(Aqhello world\*(Aq);
\&  };
\&
\&  app\->start;
.Ve
.PP
Or you can just disable format detection with a special type of restrictive
placeholder.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # /hello
\&  get \*(Aq/hello\*(Aq => [format => 0] => {text => \*(AqNo format detection.\*(Aq};
\&
\&  # Disable detection and allow the following routes to re\-enable it on demand
\&  under [format => 0];
\&
\&  # /foo
\&  get \*(Aq/foo\*(Aq => {text => \*(AqNo format detection again.\*(Aq};
\&
\&  # /bar.txt
\&  get \*(Aq/bar\*(Aq => [format => \*(Aqtxt\*(Aq] => {text => \*(Aq Just one format.\*(Aq};
\&
\&  app\->start;
.Ve
.SS "Content negotiation"
.IX Subsection "Content negotiation"
For resources with different representations and that require truly RESTful
content negotiation you can also use \*(L"respond_to\*(R" in Mojolicious::Controller.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # /hello (Accept: application/json)
\&  # /hello (Accept: application/xml)
\&  # /hello.json
\&  # /hello.xml
\&  # /hello?format=json
\&  # /hello?format=xml
\&  get \*(Aq/hello\*(Aq => sub {
\&    my $c = shift;
\&    $c\->respond_to(
\&      json => {json => {hello => \*(Aqworld\*(Aq}},
\&      xml  => {text => \*(Aq<hello>world</hello>\*(Aq},
\&      any  => {data => \*(Aq\*(Aq, status => 204}
\&    );
\&  };
\&
\&  app\->start;
.Ve
.PP
\&\s-1MIME\s0 type mappings can be extended or changed easily with
\&\*(L"types\*(R" in Mojolicious.
.PP
.Vb 1
\&  app\->types\->type(rdf => \*(Aqapplication/rdf+xml\*(Aq);
.Ve
.SS "Static files"
.IX Subsection "Static files"
Similar to templates, but with only a single file extension and optional Base64
encoding, static files can be inlined in the \f(CW\*(C`DATA\*(C'\fR section and are served
automatically.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ something.js
\&  alert(\*(Aqhello!\*(Aq);
\&
\&  @@ test.txt (base64)
\&  dGVzdCAxMjMKbGFsYWxh
.Ve
.PP
External static files are not limited to a single file extension and will be
served automatically from a \f(CW\*(C`public\*(C'\fR directory if it exists.
.PP
.Vb 3
\&  $ mkdir public
\&  $ mv something.js public/something.js
\&  $ mv mojolicious.tar.gz public/mojolicious.tar.gz
.Ve
.PP
Both have a higher precedence than routes for \f(CW\*(C`GET\*(C'\fR and \f(CW\*(C`HEAD\*(C'\fR requests.
Content negotiation with \f(CW\*(C`Range\*(C'\fR, \f(CW\*(C`If\-None\-Match\*(C'\fR and \f(CW\*(C`If\-Modified\-Since\*(C'\fR
headers is supported as well and can be tested very easily with
Mojolicious::Command::get.
.PP
.Vb 1
\&  $ ./myapp.pl get /something.js \-v \-H \*(AqRange: bytes=2\-4\*(Aq
.Ve
.SS "External templates"
.IX Subsection "External templates"
External templates will be searched by the renderer in a \f(CW\*(C`templates\*(C'\fR directory
if it exists.
.PP
.Vb 2
\&  $ mkdir \-p templates/foo
\&  $ echo \*(AqHello World!\*(Aq > templates/foo/bar.html.ep
.Ve
.PP
They have a higher precedence than templates in the \f(CW\*(C`DATA\*(C'\fR section.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Render template "templates/foo/bar.html.ep"
\&  any \*(Aq/external\*(Aq => sub {
\&    my $c = shift;
\&    $c\->render(template => \*(Aqfoo/bar\*(Aq);
\&  };
\&
\&  app\->start;
.Ve
.SS "Conditions"
.IX Subsection "Conditions"
Conditions such as \f(CW\*(C`agent\*(C'\fR and \f(CW\*(C`host\*(C'\fR from
Mojolicious::Plugin::HeaderCondition allow even more powerful route
constructs.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Firefox
\&  get \*(Aq/foo\*(Aq => (agent => qr/Firefox/) => sub {
\&    my $c = shift;
\&    $c\->render(text => \*(AqCongratulations, you are using a cool browser.\*(Aq);
\&  };
\&
\&  # Internet Explorer
\&  get \*(Aq/foo\*(Aq => (agent => qr/Internet Explorer/) => sub {
\&    my $c = shift;
\&    $c\->render(text => \*(AqDude, you really need to upgrade to Firefox.\*(Aq);
\&  };
\&
\&  # http://mojolicious.org/bar
\&  get \*(Aq/bar\*(Aq => (host => \*(Aqmojolicious.org\*(Aq) => sub {
\&    my $c = shift;
\&    $c\->render(text => \*(AqHello Mojolicious.\*(Aq);
\&  };
\&
\&  app\->start;
.Ve
.SS "Sessions"
.IX Subsection "Sessions"
Cookie-based sessions just work out of the box, as soon as you start using them
through the helper \*(L"session\*(R" in Mojolicious::Plugin::DefaultHelpers. Just be
aware that all session data gets serialized with Mojo::JSON and stored
client-side, with a cryptographic signature to prevent tampering.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Access session data in action and template
\&  get \*(Aq/counter\*(Aq => sub {
\&    my $c = shift;
\&    $c\->session\->{counter}++;
\&  };
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ counter.html.ep
\&  Counter: <%= session \*(Aqcounter\*(Aq %>
.Ve
.PP
Note that you should use custom \*(L"secrets\*(R" in Mojolicious to make signed cookies
really tamper resistant.
.PP
.Vb 1
\&  app\->secrets([\*(AqMy secret passphrase here\*(Aq]);
.Ve
.SS "File uploads"
.IX Subsection "File uploads"
All files uploaded via \f(CW\*(C`multipart/form\-data\*(C'\fR request are automatically
available as Mojo::Upload objects from \*(L"param\*(R" in Mojolicious::Controller.
And you don't have to worry about memory usage, because all files above 250KB
will be automatically streamed into a temporary file. To build \s-1HTML\s0 forms more
efficiently, you can also use tag helpers like
\&\*(L"form_for\*(R" in Mojolicious::Plugin::TagHelpers.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Upload form in DATA section
\&  get \*(Aq/\*(Aq => \*(Aqform\*(Aq;
\&
\&  # Multipart upload handler
\&  post \*(Aq/upload\*(Aq => sub {
\&    my $c = shift;
\&
\&    # Check file size
\&    return $c\->render(text => \*(AqFile is too big.\*(Aq, status => 200)
\&      if $c\->req\->is_limit_exceeded;
\&
\&    # Process uploaded file
\&    return $c\->redirect_to(\*(Aqform\*(Aq) unless my $example = $c\->param(\*(Aqexample\*(Aq);
\&    my $size = $example\->size;
\&    my $name = $example\->filename;
\&    $c\->render(text => "Thanks for uploading $size byte file $name.");
\&  };
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ form.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    <head><title>Upload</title></head>
\&    <body>
\&      %= form_for upload => (enctype => \*(Aqmultipart/form\-data\*(Aq) => begin
\&        %= file_field \*(Aqexample\*(Aq
\&        %= submit_button \*(AqUpload\*(Aq
\&      % end
\&    </body>
\&  </html>
.Ve
.PP
To protect you from excessively large files there is also a limit of 16MB by
default, which you can tweak with the attribute
\&\*(L"max_message_size\*(R" in Mojo::Message or \f(CW\*(C`MOJO_MAX_MESSAGE_SIZE\*(C'\fR environment
variable.
.PP
.Vb 2
\&  # Increase limit to 1GB
\&  $ENV{MOJO_MAX_MESSAGE_SIZE} = 1073741824;
.Ve
.SS "User agent"
.IX Subsection "User agent"
With Mojo::UserAgent, which is available through the helper
\&\*(L"ua\*(R" in Mojolicious::Plugin::DefaultHelpers, there's a full featured \s-1HTTP\s0 and
WebSocket user agent built right in. Especially in combination with
Mojo::JSON and Mojo::DOM this can be a very powerful tool.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Blocking
\&  get \*(Aq/headers\*(Aq => sub {
\&    my $c   = shift;
\&    my $url = $c\->param(\*(Aqurl\*(Aq) || \*(Aqhttp://mojolicious.org\*(Aq;
\&    my $dom = $c\->ua\->get($url)\->res\->dom;
\&    $c\->render(json => $dom\->find(\*(Aqh1, h2, h3\*(Aq)\->map(\*(Aqtext\*(Aq)\->to_array);
\&  };
\&
\&  # Non\-blocking
\&  get \*(Aq/title\*(Aq => sub {
\&    my $c = shift;
\&    $c\->ua\->get(\*(Aqmojolicious.org\*(Aq => sub {
\&      my ($ua, $tx) = @_;
\&      $c\->render(data => $tx\->res\->dom\->at(\*(Aqtitle\*(Aq)\->text);
\&    });
\&  };
\&
\&  # Concurrent non\-blocking
\&  get \*(Aq/titles\*(Aq => sub {
\&    my $c = shift;
\&    $c\->delay(
\&      sub {
\&        my $delay = shift;
\&        $c\->ua\->get(\*(Aqhttp://mojolicious.org\*(Aq => $delay\->begin);
\&        $c\->ua\->get(\*(Aqhttps://metacpan.org\*(Aq   => $delay\->begin);
\&      },
\&      sub {
\&        my ($delay, $mojo, $cpan) = @_;
\&        $c\->render(json => {
\&          mojo => $mojo\->res\->dom\->at(\*(Aqtitle\*(Aq)\->text,
\&          cpan => $cpan\->res\->dom\->at(\*(Aqtitle\*(Aq)\->text
\&        });
\&      }
\&    );
\&  };
\&
\&  app\->start;
.Ve
.PP
For more information about the user agent see also
\&\*(L"\s-1USER\s0 \s-1AGENT\s0\*(R" in Mojolicious::Guides::Cookbook.
.SS "WebSockets"
.IX Subsection "WebSockets"
WebSocket applications have never been this simple before. Just receive
messages by subscribing to events such as
\&\*(L"json\*(R" in Mojo::Transaction::WebSocket with \*(L"on\*(R" in Mojolicious::Controller and
return them with \*(L"send\*(R" in Mojolicious::Controller.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  websocket \*(Aq/echo\*(Aq => sub {
\&    my $c = shift;
\&    $c\->on(json => sub {
\&      my ($c, $hash) = @_;
\&      $hash\->{msg} = "echo: $hash\->{msg}";
\&      $c\->send({json => $hash});
\&    });
\&  };
\&
\&  get \*(Aq/\*(Aq => \*(Aqindex\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ index.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    <head>
\&      <title>Echo</title>
\&      <script>
\&        var ws = new WebSocket(\*(Aq<%= url_for(\*(Aqecho\*(Aq)\->to_abs %>\*(Aq);
\&        ws.onmessage = function (event) {
\&          document.body.innerHTML += JSON.parse(event.data).msg;
\&        };
\&        ws.onopen = function (event) {
\&          ws.send(JSON.stringify({msg: \*(AqI X Mojolicious!\*(Aq}));
\&        };
\&      </script>
\&    </head>
\&  </html>
.Ve
.PP
For more information about real-time web features see also
\&\*(L"REAL-TIME \s-1WEB\s0\*(R" in Mojolicious::Guides::Cookbook.
.SS "Mode"
.IX Subsection "Mode"
You can use the Mojo::Log object from \*(L"log\*(R" in Mojo to portably collect
debug messages and automatically disable them later in a production setup by
changing the Mojolicious operating mode, which can also be retrieved from
the attribute \*(L"mode\*(R" in Mojolicious.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Prepare mode specific message during startup
\&  my $msg = app\->mode eq \*(Aqdevelopment\*(Aq ? \*(AqDevelopment!\*(Aq : \*(AqSomething else!\*(Aq;
\&
\&  get \*(Aq/\*(Aq => sub {
\&    my $c = shift;
\&    $c\->app\->log\->debug(\*(AqRendering mode specific message\*(Aq);
\&    $c\->render(text => $msg);
\&  };
\&
\&  app\->log\->debug(\*(AqStarting application\*(Aq);
\&  app\->start;
.Ve
.PP
The default operating mode will usually be \f(CW\*(C`development\*(C'\fR and can be changed
with command line options or the \f(CW\*(C`MOJO_MODE\*(C'\fR and \f(CW\*(C`PLACK_ENV\*(C'\fR environment
variables. A mode other than \f(CW\*(C`development\*(C'\fR will raise the log level from
\&\f(CW\*(C`debug\*(C'\fR to \f(CW\*(C`info\*(C'\fR.
.PP
.Vb 1
\&  $ ./myapp.pl daemon \-m production
.Ve
.PP
All messages will be written to \f(CW\*(C`STDERR\*(C'\fR or a \f(CW\*(C`log/$mode.log\*(C'\fR file if a
\&\f(CW\*(C`log\*(C'\fR directory exists.
.PP
.Vb 1
\&  $ mkdir log
.Ve
.PP
Mode changes also affect a few other aspects of the framework, such as the
built-in \f(CW\*(C`exception\*(C'\fR and \f(CW\*(C`not_found\*(C'\fR pages. Once you switch modes from
\&\f(CW\*(C`development\*(C'\fR to \f(CW\*(C`production\*(C'\fR, no sensitive information will be revealed on
those pages anymore.
.SS "Testing"
.IX Subsection "Testing"
Testing your application is as easy as creating a \f(CW\*(C`t\*(C'\fR directory and filling it
with normal Perl tests like \f(CW\*(C`t/basic.t\*(C'\fR, which can be a lot of fun thanks to
Test::Mojo.
.PP
.Vb 2
\&  use Test::More;
\&  use Test::Mojo;
\&
\&  use FindBin;
\&  require "$FindBin::Bin/../myapp.pl";
\&
\&  my $t = Test::Mojo\->new;
\&  $t\->get_ok(\*(Aq/\*(Aq)\->status_is(200)\->content_like(qr/Funky/);
\&
\&  done_testing();
.Ve
.PP
Just run your tests with the command Mojolicious::Command::test or prove.
.PP
.Vb 3
\&  $ ./myapp.pl test
\&  $ ./myapp.pl test \-v t/basic.t
\&  $ prove \-l \-v t/basic.t
.Ve
.SH "MORE"
.IX Header "MORE"
You can continue with Mojolicious::Guides now or take a look at the
Mojolicious wiki <http://github.com/kraih/mojo/wiki>, which contains a lot
more documentation and examples by many different authors.
.SH "SUPPORT"
.IX Header "SUPPORT"
If you have any questions the documentation might not yet answer, don't
hesitate to ask on the
mailing list <http://groups.google.com/group/mojolicious> or the official \s-1IRC\s0
channel \f(CW\*(C`#mojo\*(C'\fR on \f(CW\*(C`irc.perl.org\*(C'\fR
(chat now! <https://chat.mibbit.com/?channel=%23mojo&server=irc.perl.org>).
