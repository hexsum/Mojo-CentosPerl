.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojolicious::Guides::Cookbook 3"
.TH Mojolicious::Guides::Cookbook 3 "2016-09-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojolicious::Guides::Cookbook \- Cooking with Mojolicious
.SH "OVERVIEW"
.IX Header "OVERVIEW"
This document contains many fun recipes for cooking with Mojolicious.
.SH "DEPLOYMENT"
.IX Header "DEPLOYMENT"
Getting Mojolicious and Mojolicious::Lite applications running on
different platforms. Note that many real-time web features are based on the
Mojo::IOLoop event loop, and therefore require one of the built-in web
servers to be able to use them to their full potential.
.SS "Built-in web server"
.IX Subsection "Built-in web server"
Mojolicious contains a very portable non-blocking I/O \s-1HTTP\s0 and WebSocket
server with Mojo::Server::Daemon. It is usually used during development and
in the construction of more advanced web servers, but is solid and fast enough
for small to mid sized applications.
.PP
.Vb 2
\&  $ ./script/my_app daemon
\&  Server available at http://127.0.0.1:3000
.Ve
.PP
It is available to every application through the command
Mojolicious::Command::daemon, which has many configuration options and is
known to work on every platform Perl works on with its single-process
architecture.
.PP
.Vb 2
\&  $ ./script/my_app daemon \-h
\&  ...List of available options...
.Ve
.PP
Another huge advantage is that it supports \s-1TLS\s0 and WebSockets out of the box, a
development certificate for testing purposes is built right in, so it just
works, but you can specify all listen locations supported by
\&\*(L"listen\*(R" in Mojo::Server::Daemon.
.PP
.Vb 2
\&  $ ./script/my_app daemon \-l https://[::]:3000
\&  Server available at https://[::]:3000
.Ve
.PP
To manage the web server with systemd, you can use a unit configuration file
like this.
.PP
.Vb 3
\&  [Unit]
\&  Description=My Mojolicious application
\&  After=network.target
\&
\&  [Service]
\&  Type=simple
\&  ExecStart=/home/sri/myapp/script/my_app daemon \-m production \-l http://*:8080
\&
\&  [Install]
\&  WantedBy=multi\-user.target
.Ve
.SS "Pre-forking"
.IX Subsection "Pre-forking"
On \s-1UNIX\s0 platforms you can also add pre-forking to the built-in web server and
switch to a multi-process architecture with Mojolicious::Command::prefork, to
take advantage of multiple \s-1CPU\s0 cores and copy-on-write memory management.
.PP
.Vb 2
\&  $ ./script/my_app prefork
\&  Server available at http://127.0.0.1:3000
.Ve
.PP
Since all built-in web servers are based on the Mojo::IOLoop event loop,
they scale best with non-blocking operations. But if your application for some
reason needs to perform many blocking operations, you can improve performance
by increasing the number of worker processes and decreasing the number of
concurrent connections each worker is allowed to handle (often as low as \f(CW1\fR).
.PP
.Vb 2
\&  $ ./script/my_app prefork \-m production \-w 10 \-c 1
\&  Server available at http://127.0.0.1:3000
.Ve
.PP
During startup your application is preloaded in the manager process, which does
not run an event loop, so you can use \*(L"next_tick\*(R" in Mojo::IOLoop to run code
whenever a new worker process has been forked and its event loop gets started.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  Mojo::IOLoop\->next_tick(sub {
\&    app\->log\->info("Worker $$ star...ALL GLORY TO THE HYPNOTOAD!");
\&  });
\&
\&  get \*(Aq/\*(Aq => {text => \*(AqHello Wor...ALL GLORY TO THE HYPNOTOAD!\*(Aq};
\&
\&  app\->start;
.Ve
.PP
And to manage the pre-forking web server with systemd, you can use a unit
configuration file like this.
.PP
.Vb 3
\&  [Unit]
\&  Description=My Mojolicious application
\&  After=network.target
\&
\&  [Service]
\&  Type=simple
\&  ExecStart=/home/sri/myapp/script/my_app prefork \-m production \-l http://*:8080
\&  KillMode=process
\&
\&  [Install]
\&  WantedBy=multi\-user.target
.Ve
.SS "Morbo"
.IX Subsection "Morbo"
After reading the Mojolicious::Guides::Tutorial, you should already be
familiar with Mojo::Server::Morbo.
.PP
.Vb 2
\&  Mojo::Server::Morbo
\&  +\- Mojo::Server::Daemon
.Ve
.PP
It is basically a restarter that forks a new Mojo::Server::Daemon web server
whenever a file in your project changes, and should therefore only be used
during development. To start applications with it you can use the morbo
script.
.PP
.Vb 2
\&  $ morbo ./script/my_app
\&  Server available at http://127.0.0.1:3000
.Ve
.SS "Hypnotoad"
.IX Subsection "Hypnotoad"
For bigger applications Mojolicious contains the \s-1UNIX\s0 optimized pre-forking
web server Hypnotoad, which can take advantage of
multiple \s-1CPU\s0 cores and copy-on-write memory management to scale up to thousands
of concurrent client connections.
.PP
.Vb 5
\&  Mojo::Server::Hypnotoad
\&  |\- Mojo::Server::Daemon [1]
\&  |\- Mojo::Server::Daemon [2]
\&  |\- Mojo::Server::Daemon [3]
\&  +\- Mojo::Server::Daemon [4]
.Ve
.PP
It is based on the Mojo::Server::Prefork web server, which adds pre-forking
to Mojo::Server::Daemon, but optimized specifically for production
environments out of the box. To start applications with it you can use the
hypnotoad script, which listens on port \f(CW8080\fR, automatically daemonizes
the server process and defaults to \f(CW\*(C`production\*(C'\fR mode for Mojolicious and
Mojolicious::Lite applications.
.PP
.Vb 1
\&  $ hypnotoad ./script/my_app
.Ve
.PP
Many configuration settings can be tweaked right from within your application
with \*(L"config\*(R" in Mojo, for a full list see
\&\*(L"\s-1SETTINGS\s0\*(R" in Mojo::Server::Hypnotoad.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  app\->config(hypnotoad => {listen => [\*(Aqhttp://*:80\*(Aq]});
\&
\&  get \*(Aq/\*(Aq => {text => \*(AqHello Wor...ALL GLORY TO THE HYPNOTOAD!\*(Aq};
\&
\&  app\->start;
.Ve
.PP
Or just add a \f(CW\*(C`hypnotoad\*(C'\fR section to your Mojolicious::Plugin::Config or
Mojolicious::Plugin::JSONConfig configuration file.
.PP
.Vb 7
\&  # myapp.conf
\&  {
\&    hypnotoad => {
\&      listen  => [\*(Aqhttps://*:443?cert=/etc/server.crt&key=/etc/server.key\*(Aq],
\&      workers => 10
\&    }
\&  };
.Ve
.PP
But one of its biggest advantages is the support for effortless zero downtime
software upgrades (hot deployment). That means you can upgrade Mojolicious,
Perl or even system libraries at runtime without ever stopping the server or
losing a single incoming connection, just by running the command above again.
.PP
.Vb 2
\&  $ hypnotoad ./script/my_app
\&  Starting hot deployment for Hypnotoad server 31841.
.Ve
.PP
You might also want to enable proxy support if you're using
Hypnotoad behind a reverse proxy. This allows
Mojolicious to automatically pick up the \f(CW\*(C`X\-Forwarded\-For\*(C'\fR and
\&\f(CW\*(C`X\-Forwarded\-Proto\*(C'\fR headers.
.PP
.Vb 2
\&  # myapp.conf
\&  {hypnotoad => {proxy => 1}};
.Ve
.PP
To manage Hypnotoad with systemd, you can use a unit
configuration file like this.
.PP
.Vb 3
\&  [Unit]
\&  Description=My Mojolicious application
\&  After=network.target
\&
\&  [Service]
\&  Type=forking
\&  PIDFile=/home/sri/myapp/script/hypnotoad.pid
\&  ExecStart=/path/to/hypnotoad /home/sri/myapp/script/my_app
\&  ExecReload=/path/to/hypnotoad /home/sri/myapp/script/my_app
\&  KillMode=process
\&
\&  [Install]
\&  WantedBy=multi\-user.target
.Ve
.SS "Zero downtime software upgrades"
.IX Subsection "Zero downtime software upgrades"
Hypnotoad makes zero downtime software upgrades (hot
deployment) very simple, as you can see above, but on modern operating systems
that support the \f(CW\*(C`SO_REUSEPORT\*(C'\fR socket option, there is also another method
available that works with all built-in web servers.
.PP
.Vb 2
\&  $ ./script/my_app prefork \-P /tmp/first.pid \-l http://*:8080?reuse=1
\&  Server available at http://127.0.0.1:8080
.Ve
.PP
All you have to do, is to start a second web server listening to the same port,
and stop the first web server gracefully afterwards.
.PP
.Vb 3
\&  $ ./script/my_app prefork \-P /tmp/second.pid \-l http://*:8080?reuse=1
\&  Server available at http://127.0.0.1:8080
\&  $ kill \-s TERM \`cat /tmp/first.pid\`
.Ve
.PP
Just remember that both web servers need to be started with the \f(CW\*(C`reuse\*(C'\fR
parameter.
.SS "Nginx"
.IX Subsection "Nginx"
One of the most popular setups these days is
Hypnotoad behind an Nginx <http://nginx.org> reverse
proxy, which even supports WebSockets in newer versions.
.PP
.Vb 10
\&  upstream myapp {
\&    server 127.0.0.1:8080;
\&  }
\&  server {
\&    listen 80;
\&    server_name localhost;
\&    location / {
\&      proxy_pass http://myapp;
\&      proxy_http_version 1.1;
\&      proxy_set_header Upgrade $http_upgrade;
\&      proxy_set_header Connection "upgrade";
\&      proxy_set_header Host $host;
\&      proxy_set_header X\-Forwarded\-For $proxy_add_x_forwarded_for;
\&      proxy_set_header X\-Forwarded\-Proto $scheme;
\&    }
\&  }
.Ve
.SS "Apache/mod_proxy"
.IX Subsection "Apache/mod_proxy"
Another good reverse proxy is Apache <http://httpd.apache.org> with
\&\f(CW\*(C`mod_proxy\*(C'\fR, the configuration looks quite similar to the Nginx one above. And
if you need WebSocket support, newer versions come with \f(CW\*(C`mod_proxy_wstunnel\*(C'\fR.
.PP
.Vb 10
\&  <VirtualHost *:80>
\&    ServerName localhost
\&    <Proxy *>
\&      Order deny,allow
\&      Allow from all
\&    </Proxy>
\&    ProxyRequests Off
\&    ProxyPreserveHost On
\&    ProxyPass /echo ws://localhost:8080/echo
\&    ProxyPass / http://localhost:8080/ keepalive=On
\&    ProxyPassReverse / http://localhost:8080/
\&    RequestHeader set X\-Forwarded\-Proto "http"
\&  </VirtualHost>
.Ve
.SS "Apache/CGI"
.IX Subsection "Apache/CGI"
\&\f(CW\*(C`CGI\*(C'\fR is supported out of the box and your Mojolicious application will
automatically detect that it is executed as a \f(CW\*(C`CGI\*(C'\fR script. Its use in
production environments is discouraged though, because as a result of how
\&\f(CW\*(C`CGI\*(C'\fR works, it is very slow and many web servers are making it exceptionally
hard to configure properly. Additionally, many real-time web features, such as
WebSockets, are not available.
.PP
.Vb 1
\&  ScriptAlias / /home/sri/my_app/script/my_app/
.Ve
.SS "PSGI/Plack"
.IX Subsection "PSGI/Plack"
\&\s-1PSGI\s0 is an interface between Perl web frameworks and web servers, and
Plack is a Perl module and toolkit that contains \s-1PSGI\s0 middleware, helpers
and adapters to web servers. \s-1PSGI\s0 and Plack are inspired by Python's \s-1WSGI\s0
and Ruby's Rack. Mojolicious applications are ridiculously simple to deploy
with Plack, but be aware that many real-time web features, such as
WebSockets, are not available.
.PP
.Vb 1
\&  $ plackup ./script/my_app
.Ve
.PP
Plack provides many server and protocol adapters for you to choose from,
such as \f(CW\*(C`FCGI\*(C'\fR, \f(CW\*(C`uWSGI\*(C'\fR and \f(CW\*(C`mod_perl\*(C'\fR.
.PP
.Vb 1
\&  $ plackup ./script/my_app \-s FCGI \-l /tmp/myapp.sock
.Ve
.PP
The \f(CW\*(C`MOJO_REVERSE_PROXY\*(C'\fR environment variable can be used to enable proxy
support, this allows Mojolicious to automatically pick up the
\&\f(CW\*(C`X\-Forwarded\-For\*(C'\fR and \f(CW\*(C`X\-Forwarded\-Proto\*(C'\fR headers.
.PP
.Vb 1
\&  $ MOJO_REVERSE_PROXY=1 plackup ./script/my_app
.Ve
.PP
If an older server adapter is unable to correctly detect the application home
directory, you can simply use the \f(CW\*(C`MOJO_HOME\*(C'\fR environment variable.
.PP
.Vb 1
\&  $ MOJO_HOME=/home/sri/my_app plackup ./script/my_app
.Ve
.PP
There is no need for a \f(CW\*(C`.psgi\*(C'\fR file, just point the server adapter at your
application script, it will automatically act like one if it detects the
presence of a \f(CW\*(C`PLACK_ENV\*(C'\fR environment variable.
.SS "Plack middleware"
.IX Subsection "Plack middleware"
Wrapper scripts like \f(CW\*(C`myapp.fcgi\*(C'\fR are a great way to separate deployment and
application logic.
.PP
.Vb 2
\&  #!/usr/bin/env plackup \-s FCGI
\&  use Plack::Builder;
\&
\&  builder {
\&    enable \*(AqDeflater\*(Aq;
\&    require \*(Aq./script/my_app\*(Aq;
\&  };
.Ve
.PP
Mojo::Server::PSGI can be used directly to load and customize applications
in the wrapper script.
.PP
.Vb 3
\&  #!/usr/bin/env plackup \-s FCGI
\&  use Mojo::Server::PSGI;
\&  use Plack::Builder;
\&
\&  builder {
\&    enable \*(AqDeflater\*(Aq;
\&    my $server = Mojo::Server::PSGI\->new;
\&    $server\->load_app(\*(Aq./script/my_app\*(Aq);
\&    $server\->app\->config(foo => \*(Aqbar\*(Aq);
\&    $server\->to_psgi_app;
\&  };
.Ve
.PP
But you could even use middleware right in your application.
.PP
.Vb 2
\&  use Mojolicious::Lite;
\&  use Plack::Builder;
\&
\&  get \*(Aq/welcome\*(Aq => sub {
\&    my $c = shift;
\&    $c\->render(text => \*(AqHello Mojo!\*(Aq);
\&  };
\&
\&  builder {
\&    enable \*(AqDeflater\*(Aq;
\&    app\->start;
\&  };
.Ve
.SS "Rewriting"
.IX Subsection "Rewriting"
Sometimes you might have to deploy your application in a blackbox environment
where you can't just change the server configuration or behind a reverse proxy
that passes along additional information with \f(CW\*(C`X\-Forwarded\-*\*(C'\fR headers. In such
cases you can use the hook \*(L"before_dispatch\*(R" in Mojolicious to rewrite incoming
requests.
.PP
.Vb 6
\&  # Change scheme if "X\-Forwarded\-HTTPS" header is set
\&  $app\->hook(before_dispatch => sub {
\&    my $c = shift;
\&    $c\->req\->url\->base\->scheme(\*(Aqhttps\*(Aq)
\&      if $c\->req\->headers\->header(\*(AqX\-Forwarded\-HTTPS\*(Aq);
\&  });
.Ve
.PP
Since reverse proxies generally don't pass along information about path
prefixes your application might be deployed under, rewriting the base path of
incoming requests is also quite common. This allows
\&\*(L"url_for\*(R" in Mojolicious::Controller for example, to generate portable URLs
based on the current environment.
.PP
.Vb 6
\&  # Move first part and slash from path to base path in production mode
\&  $app\->hook(before_dispatch => sub {
\&    my $c = shift;
\&    push @{$c\->req\->url\->base\->path\->trailing_slash(1)},
\&      shift @{$c\->req\->url\->path\->leading_slash(0)};
\&  }) if $app\->mode eq \*(Aqproduction\*(Aq;
.Ve
.PP
Mojo::URL objects are very easy to manipulate, just make sure that the \s-1URL\s0
(\f(CW\*(C`foo/bar?baz=yada\*(C'\fR), which represents the routing destination, is always
relative to the base \s-1URL\s0 (\f(CW\*(C`http://example.com/myapp/\*(C'\fR), which represents the
deployment location of your application.
.SS "Application embedding"
.IX Subsection "Application embedding"
From time to time you might want to reuse parts of Mojolicious applications
like configuration files, database connection or helpers for other scripts,
with this little Mojo::Server based mock server you can just embed them.
.PP
.Vb 1
\&  use Mojo::Server;
\&
\&  # Load application with mock server
\&  my $server = Mojo::Server\->new;
\&  my $app = $server\->load_app(\*(Aq./myapp.pl\*(Aq);
\&
\&  # Access fully initialized application
\&  say for @{$app\->static\->paths};
\&  say $app\->config\->{secret_identity};
\&  say $app\->dumper({just => \*(Aqa helper test\*(Aq});
\&  say $app\->build_controller\->render_to_string(template => \*(Aqfoo\*(Aq);
.Ve
.PP
The plugin Mojolicious::Plugin::Mount uses this functionality to allow you
to combine multiple applications into one and deploy them together.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  app\->config(hypnotoad => {listen => [\*(Aqhttp://*:80\*(Aq]});
\&
\&  plugin Mount => {\*(Aqtest1.example.com\*(Aq => \*(Aq/home/sri/myapp1.pl\*(Aq};
\&  plugin Mount => {\*(Aqtest2.example.com\*(Aq => \*(Aq/home/sri/myapp2.pl\*(Aq};
\&
\&  app\->start;
.Ve
.SS "Web server embedding"
.IX Subsection "Web server embedding"
You can also use \*(L"one_tick\*(R" in Mojo::IOLoop to embed the built-in web server
Mojo::Server::Daemon into alien environments like foreign event loops that
for some reason can't just be integrated with a new reactor backend.
.PP
.Vb 3
\&  use Mojolicious::Lite;
\&  use Mojo::IOLoop;
\&  use Mojo::Server::Daemon;
\&
\&  # Normal action
\&  get \*(Aq/\*(Aq => {text => \*(AqHello World!\*(Aq};
\&
\&  # Connect application with web server and start accepting connections
\&  my $daemon
\&    = Mojo::Server::Daemon\->new(app => app, listen => [\*(Aqhttp://*:8080\*(Aq]);
\&  $daemon\->start;
\&
\&  # Call "one_tick" repeatedly from the alien environment
\&  Mojo::IOLoop\->one_tick while 1;
.Ve
.SH "REAL-TIME WEB"
.IX Header "REAL-TIME WEB"
The real-time web is a collection of technologies that include Comet (long
polling), EventSource and WebSockets, which allow content to be pushed to
consumers with long-lived connections as soon as it is generated, instead of
relying on the more traditional pull model. All built-in web servers use
non-blocking I/O and are based on the Mojo::IOLoop event loop, which
provides many very powerful features that allow real-time web applications to
scale up to thousands of concurrent client connections.
.SS "Backend web services"
.IX Subsection "Backend web services"
Since Mojo::UserAgent is also based on the Mojo::IOLoop event loop, it
won't block the built-in web servers when used non-blocking, even for high
latency backend web services.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Search MetaCPAN for "mojolicious"
\&  get \*(Aq/\*(Aq => sub {
\&    my $c = shift;
\&    $c\->ua\->get(\*(Aqapi.metacpan.org/v0/module/_search?q=mojolicious\*(Aq => sub {
\&      my ($ua, $tx) = @_;
\&      $c\->render(\*(Aqmetacpan\*(Aq, hits => $tx\->res\->json\->{hits}{hits});
\&    });
\&  };
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ metacpan.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    <head><title>MetaCPAN results for "mojolicious"</title></head>
\&    <body>
\&      % for my $hit (@$hits) {
\&        <p><%= $hit\->{_source}{release} %></p>
\&      % }
\&    </body>
\&  </html>
.Ve
.PP
The callback passed to \*(L"get\*(R" in Mojo::UserAgent will be executed once the
request to the backend web service has been finished, this is called
continuation-passing style.
.SS "Synchronizing non-blocking operations"
.IX Subsection "Synchronizing non-blocking operations"
Multiple non-blocking operations, such as concurrent requests, can be easily
synchronized with \*(L"delay\*(R" in Mojolicious::Plugin::DefaultHelpers, which can help
you avoid deep nested closures that often result from continuation-passing
style.
.PP
.Vb 2
\&  use Mojolicious::Lite;
\&  use Mojo::URL;
\&
\&  # Search MetaCPAN for "mojo" and "minion"
\&  get \*(Aq/\*(Aq => sub {
\&    my $c = shift;
\&
\&    # Prepare response in two steps
\&    $c\->delay(
\&
\&      # Concurrent requests
\&      sub {
\&        my $delay = shift;
\&        my $url   = Mojo::URL\->new(\*(Aqapi.metacpan.org/v0/module/_search\*(Aq);
\&        $url\->query({sort => \*(Aqdate:desc\*(Aq});
\&        $c\->ua\->get($url\->clone\->query({q => \*(Aqmojo\*(Aq})   => $delay\->begin);
\&        $c\->ua\->get($url\->clone\->query({q => \*(Aqminion\*(Aq}) => $delay\->begin);
\&      },
\&
\&      # Delayed rendering
\&      sub {
\&        my ($delay, $mojo, $minion) = @_;
\&        $c\->render(json => {
\&          mojo   => $mojo\->res\->json(\*(Aq/hits/hits/0/_source/release\*(Aq),
\&          minion => $minion\->res\->json(\*(Aq/hits/hits/0/_source/release\*(Aq)
\&        });
\&      }
\&    );
\&  };
\&
\&  app\->start;
.Ve
.PP
You simply use \*(L"begin\*(R" in Mojo::IOLoop::Delay to generate callbacks that can be
passed to \*(L"get\*(R" in Mojo::UserAgent. These callbacks then capture arguments
passed to them, and pass them on to the next step in the chain, once all
generated callbacks have been executed.
.SS "Timers"
.IX Subsection "Timers"
Timers, another primary feature of the event loop, are created with
\&\*(L"timer\*(R" in Mojo::IOLoop and can, for example, be used to delay rendering of a
response, and unlike \f(CW\*(C`sleep\*(C'\fR, won't block any other requests that might be
processed concurrently.
.PP
.Vb 2
\&  use Mojolicious::Lite;
\&  use Mojo::IOLoop;
\&
\&  # Wait 3 seconds before rendering a response
\&  get \*(Aq/\*(Aq => sub {
\&    my $c = shift;
\&    Mojo::IOLoop\->timer(3 => sub {
\&      $c\->render(text => \*(AqDelayed by 3 seconds!\*(Aq);
\&    });
\&  };
\&
\&  app\->start;
.Ve
.PP
Recurring timers created with \*(L"recurring\*(R" in Mojo::IOLoop are slightly more
powerful, but need to be stopped manually, or they would just keep getting
emitted.
.PP
.Vb 2
\&  use Mojolicious::Lite;
\&  use Mojo::IOLoop;
\&
\&  # Count to 5 in 1 second steps
\&  get \*(Aq/\*(Aq => sub {
\&    my $c = shift;
\&
\&    # Start recurring timer
\&    my $i = 1;
\&    my $id = Mojo::IOLoop\->recurring(1 => sub {
\&      $c\->write_chunk($i);
\&      $c\->finish if $i++ == 5;
\&    });
\&
\&    # Stop recurring timer
\&    $c\->on(finish => sub { Mojo::IOLoop\->remove($id) });
\&  };
\&
\&  app\->start;
.Ve
.PP
Timers are not tied to a specific request or connection, and can even be
created at startup time.
.PP
.Vb 2
\&  use Mojolicious::Lite;
\&  use Mojo::IOLoop;
\&
\&  # Check title in the background every 10 seconds
\&  my $title = \*(AqGot no title yet.\*(Aq;
\&  Mojo::IOLoop\->recurring(10 => sub {
\&    app\->ua\->get(\*(Aqhttp://mojolicious.org\*(Aq => sub {
\&      my ($ua, $tx) = @_;
\&      $title = $tx\->res\->dom\->at(\*(Aqtitle\*(Aq)\->text;
\&    });
\&  });
\&
\&  # Show current title
\&  get \*(Aq/\*(Aq => sub {
\&    my $c = shift;
\&    $c\->render(json => {title => $title});
\&  };
\&
\&  app\->start;
.Ve
.PP
Just remember that all these non-blocking operations are processed
cooperatively, so your callbacks shouldn't block for too long.
.SS "Subprocesses"
.IX Subsection "Subprocesses"
You can also use subprocesses, created with \*(L"subprocess\*(R" in Mojo::IOLoop, to
perform computationally expensive operations without blocking the event loop.
.PP
.Vb 2
\&  use Mojolicious::Lite;
\&  use Mojo::IOLoop;
\&
\&  # Operation that would block the event loop for 5 seconds
\&  get \*(Aq/\*(Aq => sub {
\&    my $c = shift;
\&    Mojo::IOLoop\->subprocess(
\&      sub {
\&        my $subprocess = shift;
\&        sleep 5;
\&        return \*(AqX\*(Aq, \*(AqMojolicious\*(Aq;
\&      },
\&      sub {
\&        my ($subprocess, $err, @results) = @_;
\&        return $c\->reply\->exception($err) if $err;
\&        $c\->render(text => "I $results[0] $results[1]!");
\&      }
\&    );
\&  };
\&
\&  app\->start;
.Ve
.PP
The first callback will be executed in a child process, without blocking the
event loop of the parent process. The results of the first callback will then be
shared between both processes, and the second callback executed in the parent
process.
.SS "Exceptions in non-blocking operations"
.IX Subsection "Exceptions in non-blocking operations"
Since timers and other non-blocking operations are running solely in the event
loop, outside of the application, exceptions that get thrown in callbacks can't
get caught and handled automatically. But you can handle them manually by
subscribing to the event \*(L"error\*(R" in Mojo::Reactor or catching them inside the
callback.
.PP
.Vb 2
\&  use Mojolicious::Lite;
\&  use Mojo::IOLoop;
\&
\&  # Forward error messages to the application log
\&  Mojo::IOLoop\->singleton\->reactor\->on(error => sub {
\&    my ($reactor, $err) = @_;
\&    app\->log\->error($err);
\&  });
\&
\&  # Exception only gets logged (and connection times out)
\&  get \*(Aq/connection_times_out\*(Aq => sub {
\&    my $c = shift;
\&    Mojo::IOLoop\->timer(2 => sub {
\&      die \*(AqThis request will not be getting a response\*(Aq;
\&    });
\&  };
\&
\&  # Exception gets caught and handled
\&  get \*(Aq/catch_exception\*(Aq => sub {
\&    my $c = shift;
\&    Mojo::IOLoop\->timer(2 => sub {
\&      eval { die \*(AqThis request will be getting a response\*(Aq };
\&      $c\->reply\->exception($@) if $@;
\&    });
\&  };
\&
\&  app\->start;
.Ve
.PP
A default subscriber that turns all errors into warnings will usually be added
by Mojo::IOLoop as a fallback.
.PP
.Vb 1
\&  Mojo::IOLoop\->singleton\->reactor\->unsubscribe(\*(Aqerror\*(Aq);
.Ve
.PP
During development or for applications where crashing is simply preferable, you
can also make every exception that gets thrown in a callback fatal by removing
all of its subscribers.
.SS "WebSocket web service"
.IX Subsection "WebSocket web service"
The WebSocket protocol offers full bi-directional low-latency communication
channels between clients and servers. Receive messages just by subscribing to
events such as \*(L"message\*(R" in Mojo::Transaction::WebSocket with
\&\*(L"on\*(R" in Mojolicious::Controller and return them with
\&\*(L"send\*(R" in Mojolicious::Controller.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Template with browser\-side code
\&  get \*(Aq/\*(Aq => \*(Aqindex\*(Aq;
\&
\&  # WebSocket echo service
\&  websocket \*(Aq/echo\*(Aq => sub {
\&    my $c = shift;
\&
\&    # Opened
\&    $c\->app\->log\->debug(\*(AqWebSocket opened\*(Aq);
\&
\&    # Increase inactivity timeout for connection a bit
\&    $c\->inactivity_timeout(300);
\&
\&    # Incoming message
\&    $c\->on(message => sub {
\&      my ($c, $msg) = @_;
\&      $c\->send("echo: $msg");
\&    });
\&
\&    # Closed
\&    $c\->on(finish => sub {
\&      my ($c, $code, $reason) = @_;
\&      $c\->app\->log\->debug("WebSocket closed with status $code");
\&    });
\&  };
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ index.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    <head><title>Echo</title></head>
\&    <body>
\&      <script>
\&        var ws = new WebSocket(\*(Aq<%= url_for(\*(Aqecho\*(Aq)\->to_abs %>\*(Aq);
\&
\&        // Incoming messages
\&        ws.onmessage = function (event) {
\&          document.body.innerHTML += event.data + \*(Aq<br/>\*(Aq;
\&        };
\&
\&        // Outgoing messages
\&        ws.onopen = function (event) {
\&          window.setInterval(function () { ws.send(\*(AqHello Mojo!\*(Aq) }, 1000);
\&        };
\&      </script>
\&    </body>
\&  </html>
.Ve
.PP
The event \*(L"finish\*(R" in Mojo::Transaction::WebSocket will be emitted right after
the WebSocket connection has been closed.
.PP
.Vb 1
\&  $c\->tx\->with_compression;
.Ve
.PP
You can activate \f(CW\*(C`permessage\-deflate\*(C'\fR compression with
\&\*(L"with_compression\*(R" in Mojo::Transaction::WebSocket, this can result in much
better performance, but also increases memory usage by up to 300KB per
connection.
.PP
.Vb 1
\&  my $proto = $c\->tx\->with_protocols(\*(Aqv2.proto\*(Aq, \*(Aqv1.proto\*(Aq);
.Ve
.PP
You can also use \*(L"with_protocols\*(R" in Mojo::Transaction::WebSocket to negotiate a
subprotocol.
.SS "Testing WebSocket web services"
.IX Subsection "Testing WebSocket web services"
While the message flow on WebSocket connections can be rather dynamic, it more
often than not is quite predictable, which allows this rather pleasant
Test::Mojo \s-1API\s0 to be used.
.PP
.Vb 2
\&  use Test::More;
\&  use Test::Mojo;
\&
\&  # Include application
\&  use FindBin;
\&  require "$FindBin::Bin/../echo.pl";
\&
\&  # Test echo web service
\&  my $t = Test::Mojo\->new;
\&  $t\->websocket_ok(\*(Aq/echo\*(Aq)
\&    \->send_ok(\*(AqHello Mojo!\*(Aq)
\&    \->message_ok
\&    \->message_is(\*(Aqecho: Hello Mojo!\*(Aq)
\&    \->finish_ok;
\&
\&  # Test JSON web service
\&  $t\->websocket_ok(\*(Aq/echo.json\*(Aq)
\&    \->send_ok({json => {test => [1, 2, 3]}})
\&    \->message_ok
\&    \->json_message_is(\*(Aq/test\*(Aq, [1, 2, 3])
\&    \->finish_ok;
\&
\&  done_testing();
.Ve
.SS "EventSource web service"
.IX Subsection "EventSource web service"
EventSource is a special form of long polling where you can use
\&\*(L"write\*(R" in Mojolicious::Controller to directly send \s-1DOM\s0 events from servers to
clients. It is uni-directional, that means you will have to use Ajax requests
for sending data from clients to servers, the advantage however is low
infrastructure requirements, since it reuses the \s-1HTTP\s0 protocol for transport.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  # Template with browser\-side code
\&  get \*(Aq/\*(Aq => \*(Aqindex\*(Aq;
\&
\&  # EventSource for log messages
\&  get \*(Aq/events\*(Aq => sub {
\&    my $c = shift;
\&
\&    # Increase inactivity timeout for connection a bit
\&    $c\->inactivity_timeout(300);
\&
\&    # Change content type and finalize response headers
\&    $c\->res\->headers\->content_type(\*(Aqtext/event\-stream\*(Aq);
\&    $c\->write;
\&
\&    # Subscribe to "message" event and forward "log" events to browser
\&    my $cb = $c\->app\->log\->on(message => sub {
\&      my ($log, $level, @lines) = @_;
\&      $c\->write("event:log\endata: [$level] @lines\en\en");
\&    });
\&
\&    # Unsubscribe from "message" event again once we are done
\&    $c\->on(finish => sub {
\&      my $c = shift;
\&      $c\->app\->log\->unsubscribe(message => $cb);
\&    });
\&  };
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ index.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    <head><title>LiveLog</title></head>
\&    <body>
\&      <script>
\&        var events = new EventSource(\*(Aq<%= url_for \*(Aqevents\*(Aq %>\*(Aq);
\&
\&        // Subscribe to "log" event
\&        events.addEventListener(\*(Aqlog\*(Aq, function (event) {
\&          document.body.innerHTML += event.data + \*(Aq<br/>\*(Aq;
\&        }, false);
\&      </script>
\&    </body>
\&  </html>
.Ve
.PP
The event \*(L"message\*(R" in Mojo::Log will be emitted for every new log message and
the event \*(L"finish\*(R" in Mojo::Transaction right after the transaction has been
finished.
.SS "Streaming multipart uploads"
.IX Subsection "Streaming multipart uploads"
Mojolicious contains a very sophisticated event system based on
Mojo::EventEmitter, with ready-to-use events on almost all layers, and which
can be combined to solve some of hardest problems in web development.
.PP
.Vb 2
\&  use Mojolicious::Lite;
\&  use Scalar::Util \*(Aqweaken\*(Aq;
\&
\&  # Intercept multipart uploads and log each chunk received
\&  hook after_build_tx => sub {
\&    my $tx = shift;
\&
\&    # Subscribe to "upgrade" event to identify multipart uploads
\&    weaken $tx;
\&    $tx\->req\->content\->on(upgrade => sub {
\&      my ($single, $multi) = @_;
\&      return unless $tx\->req\->url\->path\->contains(\*(Aq/upload\*(Aq);
\&
\&      # Subscribe to "part" event to find the right one
\&      $multi\->on(part => sub {
\&        my ($multi, $single) = @_;
\&
\&        # Subscribe to "body" event of part to make sure we have all headers
\&        $single\->on(body => sub {
\&          my $single = shift;
\&
\&          # Make sure we have the right part and replace "read" event
\&          return unless $single\->headers\->content_disposition =~ /example/;
\&          $single\->unsubscribe(\*(Aqread\*(Aq)\->on(read => sub {
\&            my ($single, $bytes) = @_;
\&
\&            # Log size of every chunk we receive
\&            app\->log\->debug(length($bytes) . \*(Aq bytes uploaded\*(Aq);
\&          });
\&        });
\&      });
\&    });
\&  };
\&
\&  # Upload form in DATA section
\&  get \*(Aq/\*(Aq => \*(Aqindex\*(Aq;
\&
\&  # Streaming multipart upload
\&  post \*(Aq/upload\*(Aq => {text => \*(AqUpload was successful.\*(Aq};
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&
\&  @@ index.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    <head><title>Streaming multipart upload</title></head>
\&    <body>
\&      %= form_for upload => (enctype => \*(Aqmultipart/form\-data\*(Aq) => begin
\&        %= file_field \*(Aqexample\*(Aq
\&        %= submit_button \*(AqUpload\*(Aq
\&      % end
\&    </body>
\&  </html>
.Ve
.SS "Event loops"
.IX Subsection "Event loops"
Internally, the Mojo::IOLoop event loop can use multiple reactor backends,
\&\s-1EV\s0 for example, will be automatically used if possible. Which in turn allows
other event loops like AnyEvent to just work.
.PP
.Vb 3
\&  use Mojolicious::Lite;
\&  use EV;
\&  use AnyEvent;
\&
\&  # Wait 3 seconds before rendering a response
\&  get \*(Aq/\*(Aq => sub {
\&    my $c = shift;
\&    my $w;
\&    $w = AE::timer 3, 0, sub {
\&      $c\->render(text => \*(AqDelayed by 3 seconds!\*(Aq);
\&      undef $w;
\&    };
\&  };
\&
\&  app\->start;
.Ve
.PP
Who actually controls the event loop backend is not important.
.PP
.Vb 3
\&  use Mojo::UserAgent;
\&  use EV;
\&  use AnyEvent;
\&
\&  # Search MetaCPAN for "mojolicious"
\&  my $cv = AE::cv;
\&  my $ua = Mojo::UserAgent\->new;
\&  $ua\->get(\*(Aqapi.metacpan.org/v0/module/_search?q=mojolicious\*(Aq => sub {
\&    my ($ua, $tx) = @_;
\&    $cv\->send($tx\->res\->json(\*(Aq/hits/hits/0/_source/release\*(Aq));
\&  });
\&  say $cv\->recv;
.Ve
.PP
You could, for example, just embed the built-in web server into an AnyEvent
application.
.PP
.Vb 4
\&  use Mojolicious::Lite;
\&  use Mojo::Server::Daemon;
\&  use EV;
\&  use AnyEvent;
\&
\&  # Normal action
\&  get \*(Aq/\*(Aq => {text => \*(AqHello World!\*(Aq};
\&
\&  # Connect application with web server and start accepting connections
\&  my $daemon
\&    = Mojo::Server::Daemon\->new(app => app, listen => [\*(Aqhttp://*:8080\*(Aq]);
\&  $daemon\->start;
\&
\&  # Let AnyEvent take control
\&  AE::cv\->recv;
.Ve
.SH "USER AGENT"
.IX Header "USER AGENT"
When we say Mojolicious is a web framework we actually mean it, with
Mojo::UserAgent there's a full featured \s-1HTTP\s0 and WebSocket user agent built
right in.
.SS "Web scraping"
.IX Subsection "Web scraping"
Scraping information from websites has never been this much fun before. The
built-in \s-1HTML/XML\s0 parser Mojo::DOM is accessible through
\&\*(L"dom\*(R" in Mojo::Message and supports all \s-1CSS\s0 selectors that make sense for a
standalone parser, it can be a very powerful tool especially for testing web
application.
.PP
.Vb 1
\&  use Mojo::UserAgent;
\&
\&  # Fetch website
\&  my $ua = Mojo::UserAgent\->new;
\&  my $tx = $ua\->get(\*(Aqmojolicious.org/perldoc\*(Aq);
\&
\&  # Extract title
\&  say \*(AqTitle: \*(Aq, $tx\->res\->dom\->at(\*(Aqhead > title\*(Aq)\->text;
\&
\&  # Extract headings
\&  $tx\->res\->dom(\*(Aqh1, h2, h3\*(Aq)\->each(sub { say \*(AqHeading: \*(Aq, shift\->all_text });
\&
\&  # Visit all nodes recursively to extract more than just text
\&  for my $n ($tx\->res\->dom\->descendant_nodes\->each) {
\&
\&    # Text or CDATA node
\&    print $n\->content if $n\->type eq \*(Aqtext\*(Aq || $n\->type eq \*(Aqcdata\*(Aq;
\&
\&    # Also include alternate text for images
\&    print $n\->{alt} if $n\->type eq \*(Aqtag\*(Aq && $n\->tag eq \*(Aqimg\*(Aq;
\&  }
.Ve
.PP
For a full list of available \s-1CSS\s0 selectors see \*(L"\s-1SELECTORS\s0\*(R" in Mojo::DOM::CSS.
.SS "\s-1JSON\s0 web services"
.IX Subsection "JSON web services"
Most web services these days are based on the \s-1JSON\s0 data-interchange format.
That's why Mojolicious comes with the possibly fastest pure-Perl
implementation Mojo::JSON built right in, which is accessible through
\&\*(L"json\*(R" in Mojo::Message.
.PP
.Vb 2
\&  use Mojo::UserAgent;
\&  use Mojo::URL;
\&
\&  # Fresh user agent
\&  my $ua = Mojo::UserAgent\->new;
\&
\&  # Search MetaCPAN for "mojolicious" and list latest releases
\&  my $url = Mojo::URL\->new(\*(Aqhttp://api.metacpan.org/v0/release/_search\*(Aq);
\&  $url\->query({q => \*(Aqmojolicious\*(Aq, sort => \*(Aqdate:desc\*(Aq});
\&  for my $hit (@{$ua\->get($url)\->res\->json\->{hits}{hits}}) {
\&    say "$hit\->{_source}{name} ($hit\->{_source}{author})";
\&  }
.Ve
.SS "Basic authentication"
.IX Subsection "Basic authentication"
You can just add username and password to the \s-1URL\s0, an \f(CW\*(C`Authorization\*(C'\fR header
will be automatically generated.
.PP
.Vb 1
\&  use Mojo::UserAgent;
\&
\&  my $ua = Mojo::UserAgent\->new;
\&  say $ua\->get(\*(Aqhttps://sri:secret@example.com/hideout\*(Aq)\->res\->body;
.Ve
.SS "Decorating follow-up requests"
.IX Subsection "Decorating follow-up requests"
Mojo::UserAgent can automatically follow redirects, the event
\&\*(L"start\*(R" in Mojo::UserAgent allows you direct access to each transaction right
after they have been initialized and before a connection gets associated with
them.
.PP
.Vb 1
\&  use Mojo::UserAgent;
\&
\&  # User agent following up to 10 redirects
\&  my $ua = Mojo::UserAgent\->new(max_redirects => 10);
\&
\&  # Add a witty header to every request
\&  $ua\->on(start => sub {
\&    my ($ua, $tx) = @_;
\&    $tx\->req\->headers\->header(\*(AqX\-Bender\*(Aq => \*(AqBite my shiny metal ass!\*(Aq);
\&    say \*(AqRequest: \*(Aq, $tx\->req\->url\->clone\->to_abs;
\&  });
\&
\&  # Request that will most likely get redirected
\&  say \*(AqTitle: \*(Aq, $ua\->get(\*(Aqgoogle.com\*(Aq)\->res\->dom\->at(\*(Aqhead > title\*(Aq)\->text;
.Ve
.PP
This even works for proxy \f(CW\*(C`CONNECT\*(C'\fR requests.
.SS "Content generators"
.IX Subsection "Content generators"
Content generators can be registered with
\&\*(L"add_generator\*(R" in Mojo::UserAgent::Transactor to generate the same type of
content repeatedly for multiple requests.
.PP
.Vb 2
\&  use Mojo::UserAgent;
\&  use Mojo::Asset::File;
\&
\&  # Add "stream" generator
\&  my $ua = Mojo::UserAgent\->new;
\&  $ua\->transactor\->add_generator(stream => sub {
\&    my ($transactor, $tx, $path) = @_;
\&    $tx\->req\->content\->asset(Mojo::Asset::File\->new(path => $path));
\&  });
\&
\&  # Send multiple files streaming via PUT and POST
\&  $ua\->put(\*(Aqhttp://example.com/upload\*(Aq  => stream => \*(Aq/home/sri/mojo.png\*(Aq);
\&  $ua\->post(\*(Aqhttp://example.com/upload\*(Aq => stream => \*(Aq/home/sri/minion.png\*(Aq);
.Ve
.PP
The \f(CW\*(C`json\*(C'\fR and \f(CW\*(C`form\*(C'\fR content generators are always available.
.PP
.Vb 1
\&  use Mojo::UserAgent;
\&
\&  # Send "application/json" content via PATCH
\&  my $ua = Mojo::UserAgent\->new;
\&  my $tx = $ua\->patch(\*(Aqhttp://api.example.com\*(Aq => json => {foo => \*(Aqbar\*(Aq});
\&
\&  # Send query parameters via GET
\&  my $tx2 = $ua\->get(\*(Aqhttp://search.example.com\*(Aq => form => {q => \*(Aqtest\*(Aq});
\&
\&  # Send "application/x\-www\-form\-urlencoded" content via POST
\&  my $tx3 = $ua\->post(\*(Aqhttp://search.example.com\*(Aq => form => {q => \*(Aqtest\*(Aq});
\&
\&  # Send "multipart/form\-data" content via PUT
\&  my $tx4 = $ua\->put(\*(Aqhttp://upload.example.com\*(Aq =>
\&    form => {test => {content => \*(AqHello World!\*(Aq}});
.Ve
.PP
For more information about available content generators see also
\&\*(L"tx\*(R" in Mojo::UserAgent::Transactor.
.SS "Large file downloads"
.IX Subsection "Large file downloads"
When downloading large files with Mojo::UserAgent you don't have to worry
about memory usage at all, because it will automatically stream everything
above 250KB into a temporary file, which can then be moved into a permanent
file with \*(L"move_to\*(R" in Mojo::Asset::File.
.PP
.Vb 1
\&  use Mojo::UserAgent;
\&
\&  # Fetch the latest Mojolicious tarball
\&  my $ua = Mojo::UserAgent\->new(max_redirects => 5);
\&  my $tx = $ua\->get(\*(Aqhttps://www.github.com/kraih/mojo/tarball/master\*(Aq);
\&  $tx\->res\->content\->asset\->move_to(\*(Aqmojo.tar.gz\*(Aq);
.Ve
.PP
To protect you from excessively large files there is also a limit of 16MB by
default, which you can tweak with the attribute
\&\*(L"max_message_size\*(R" in Mojo::Message or \f(CW\*(C`MOJO_MAX_MESSAGE_SIZE\*(C'\fR environment
variable.
.PP
.Vb 2
\&  # Increase limit to 1GB
\&  $ENV{MOJO_MAX_MESSAGE_SIZE} = 1073741824;
.Ve
.SS "Large file upload"
.IX Subsection "Large file upload"
Uploading a large file is even easier.
.PP
.Vb 1
\&  use Mojo::UserAgent;
\&
\&  # Upload file via POST and "multipart/form\-data"
\&  my $ua = Mojo::UserAgent\->new;
\&  $ua\->post(\*(Aqexample.com/upload\*(Aq =>
\&    form => {image => {file => \*(Aq/home/sri/hello.png\*(Aq}});
.Ve
.PP
And once again you don't have to worry about memory usage, all data will be
streamed directly from the file.
.SS "Streaming response"
.IX Subsection "Streaming response"
Receiving a streaming response can be really tricky in most \s-1HTTP\s0 clients, but
Mojo::UserAgent makes it actually easy.
.PP
.Vb 1
\&  use Mojo::UserAgent;
\&
\&  # Build a normal transaction
\&  my $ua = Mojo::UserAgent\->new;
\&  my $tx = $ua\->build_tx(GET => \*(Aqhttp://example.com\*(Aq);
\&
\&  # Accept response of indefinite size
\&  $tx\->res\->max_message_size(0);
\&
\&  # Replace "read" events to disable default content parser
\&  $tx\->res\->content\->unsubscribe(\*(Aqread\*(Aq)\->on(read => sub {
\&    my ($content, $bytes) = @_;
\&    say "Streaming: $bytes";
\&  });
\&
\&  # Process transaction
\&  $tx = $ua\->start($tx);
.Ve
.PP
The event \*(L"read\*(R" in Mojo::Content will be emitted for every chunk of data that
is received, even chunked transfer encoding and gzip content encoding will be
handled transparently if necessary.
.SS "Streaming request"
.IX Subsection "Streaming request"
Sending a streaming request is almost just as easy.
.PP
.Vb 1
\&  use Mojo::UserAgent;
\&
\&  # Build a normal transaction
\&  my $ua = Mojo::UserAgent\->new;
\&  my $tx = $ua\->build_tx(GET => \*(Aqhttp://example.com\*(Aq);
\&
\&  # Prepare body
\&  my $body = \*(AqHello World!\*(Aq;
\&  $tx\->req\->headers\->content_length(length $body);
\&
\&  # Start writing directly with a drain callback
\&  my $drain;
\&  $drain = sub {
\&    my $content = shift;
\&    my $chunk = substr $body, 0, 1, \*(Aq\*(Aq;
\&    $drain = undef unless length $body;
\&    $content\->write($chunk, $drain);
\&  };
\&  $tx\->req\->content\->$drain;
\&
\&  # Process transaction
\&  $tx = $ua\->start($tx);
.Ve
.PP
The drain callback passed to \*(L"write\*(R" in Mojo::Content will be executed whenever
the entire previous chunk of data has actually been written.
.SS "Non-blocking"
.IX Subsection "Non-blocking"
Mojo::UserAgent has been designed from the ground up to be non-blocking, the
whole blocking \s-1API\s0 is just a simple convenience wrapper. Especially for high
latency tasks like web crawling this can be extremely useful, because you can
keep many concurrent connections active at the same time.
.PP
.Vb 2
\&  use Mojo::UserAgent;
\&  use Mojo::IOLoop;
\&
\&  # Concurrent non\-blocking requests
\&  my $ua = Mojo::UserAgent\->new;
\&  $ua\->get(\*(Aqhttp://metacpan.org/search?q=mojo\*(Aq => sub {
\&    my ($ua, $mojo) = @_;
\&    say $mojo\->res\->dom\->at(\*(Aqtitle\*(Aq)\->text;
\&  });
\&  $ua\->get(\*(Aqhttp://metacpan.org/search?q=minion\*(Aq => sub {
\&    my ($ua, $minion) = @_;
\&    say $minion\->res\->dom\->at(\*(Aqtitle\*(Aq)\->text;
\&  });
\&
\&  # Start event loop if necessary
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.PP
You can take full control of the Mojo::IOLoop event loop.
.SS "Concurrent blocking requests"
.IX Subsection "Concurrent blocking requests"
You can emulate blocking behavior by using \*(L"delay\*(R" in Mojo::IOLoop to
synchronize multiple non-blocking requests.
.PP
.Vb 2
\&  use Mojo::UserAgent;
\&  use Mojo::IOLoop;
\&
\&  # Synchronize non\-blocking requests
\&  my $ua    = Mojo::UserAgent\->new;
\&  my $delay = Mojo::IOLoop\->delay(sub {
\&    my ($delay, $mojo, $minion) = @_;
\&    say $mojo\->res\->dom\->at(\*(Aqtitle\*(Aq)\->text;
\&    say $minion\->res\->dom\->at(\*(Aqtitle\*(Aq)\->text;
\&  });
\&  $ua\->get(\*(Aqhttp://metacpan.org/search?q=mojo\*(Aq   => $delay\->begin);
\&  $ua\->get(\*(Aqhttp://metacpan.org/search?q=minion\*(Aq => $delay\->begin);
\&  $delay\->wait;
.Ve
.PP
The call to \*(L"wait\*(R" in Mojo::IOLoop::Delay makes this code portable, it can now
work inside an already running event loop or start one on demand.
.SS "WebSockets"
.IX Subsection "WebSockets"
WebSockets are not just for the server-side, you can use
\&\*(L"websocket\*(R" in Mojo::UserAgent to open new connections, which are always
non-blocking. The WebSocket handshake uses \s-1HTTP\s0, and is a normal \f(CW\*(C`GET\*(C'\fR request
with a few additional headers. It can even contain cookies, and is followed by
a \f(CW101\fR response from the server, notifying our user agent that the connection
has been established and it can start using the bi-directional WebSocket
protocol.
.PP
.Vb 2
\&  use Mojo::UserAgent;
\&  use Mojo::IOLoop;
\&
\&  # Open WebSocket to echo service
\&  my $ua = Mojo::UserAgent\->new;
\&  $ua\->websocket(\*(Aqws://echo.websocket.org\*(Aq => sub {
\&    my ($ua, $tx) = @_;
\&
\&    # Check if WebSocket handshake was successful
\&    say \*(AqWebSocket handshake failed!\*(Aq and return unless $tx\->is_websocket;
\&
\&    # Wait for WebSocket to be closed
\&    $tx\->on(finish => sub {
\&      my ($tx, $code, $reason) = @_;
\&      say "WebSocket closed with status $code.";
\&    });
\&
\&    # Close WebSocket after receiving one message
\&    $tx\->on(message => sub {
\&      my ($tx, $msg) = @_;
\&      say "WebSocket message: $msg";
\&      $tx\->finish;
\&    });
\&
\&    # Send a message to the server
\&    $tx\->send(\*(AqHi!\*(Aq);
\&  });
\&
\&  # Start event loop if necessary
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SS "Command line"
.IX Subsection "Command line"
Don't you hate checking huge \s-1HTML\s0 files from the command line? Thanks to the
command Mojolicious::Command::get that is about to change. You can just pick
the parts that actually matter with the \s-1CSS\s0 selectors from Mojo::DOM and
\&\s-1JSON\s0 Pointers from Mojo::JSON::Pointer.
.PP
.Vb 1
\&  $ mojo get http://mojolicious.org \*(Aqhead > title\*(Aq
.Ve
.PP
How about a list of all id attributes?
.PP
.Vb 1
\&  $ mojo get http://mojolicious.org \*(Aq*\*(Aq attr id
.Ve
.PP
Or the text content of all heading tags?
.PP
.Vb 1
\&  $ mojo get http://mojolicious.org \*(Aqh1, h2, h3\*(Aq text
.Ve
.PP
Maybe just the text of the third heading?
.PP
.Vb 1
\&  $ mojo get http://mojolicious.org \*(Aqh1, h2, h3\*(Aq 3 text
.Ve
.PP
You can also extract all text from nested child elements.
.PP
.Vb 1
\&  $ mojo get http://mojolicious.org \*(Aq#mojobar\*(Aq all
.Ve
.PP
The request can be customized as well.
.PP
.Vb 2
\&  $ mojo get \-M POST \-c \*(AqHello!\*(Aq http://mojolicious.org
\&  $ mojo get \-H \*(AqX\-Bender: Bite my shiny metal ass!\*(Aq http://google.com
.Ve
.PP
You can follow redirects and view the headers for all messages.
.PP
.Vb 1
\&  $ mojo get \-r \-v http://google.com \*(Aqhead > title\*(Aq
.Ve
.PP
Extract just the information you really need from \s-1JSON\s0 data structures.
.PP
.Vb 1
\&  $ mojo get https://api.metacpan.org/v0/author/SRI /name
.Ve
.PP
This can be an invaluable tool for testing your applications.
.PP
.Vb 1
\&  $ ./myapp.pl get /welcome \*(Aqhead > title\*(Aq
.Ve
.SS "One-liners"
.IX Subsection "One-liners"
For quick hacks and especially testing, ojo one-liners are also a great
choice.
.PP
.Vb 1
\&  $ perl \-Mojo \-E \*(Aqsay g("mojolicious.org")\->dom\->at("title")\->text\*(Aq
.Ve
.SH "APPLICATIONS"
.IX Header "APPLICATIONS"
Fun Mojolicious application hacks for all occasions.
.SS "Basic authentication"
.IX Subsection "Basic authentication"
Basic authentication data will be automatically extracted from the
\&\f(CW\*(C`Authorization\*(C'\fR header.
.PP
.Vb 2
\&  use Mojolicious::Lite;
\&  use Mojo::Util \*(Aqsecure_compare\*(Aq;
\&
\&  get \*(Aq/\*(Aq => sub {
\&    my $c = shift;
\&
\&    # Check for username "Bender" and password "rocks"
\&    return $c\->render(text => \*(AqHello Bender!\*(Aq)
\&      if secure_compare $c\->req\->url\->to_abs\->userinfo, \*(AqBender:rocks\*(Aq;
\&
\&    # Require authentication
\&    $c\->res\->headers\->www_authenticate(\*(AqBasic\*(Aq);
\&    $c\->render(text => \*(AqAuthentication required!\*(Aq, status => 401);
\&  };
\&
\&  app\->start;
.Ve
.PP
This can be combined with \s-1TLS\s0 for a secure authentication mechanism.
.PP
.Vb 1
\&  $ ./myapp.pl daemon \-l \*(Aqhttps://*:3000?cert=./server.crt&key=./server.key\*(Aq
.Ve
.SS "Adding a configuration file"
.IX Subsection "Adding a configuration file"
Adding a configuration file to your application is as easy as adding a file to
its home directory and loading the plugin Mojolicious::Plugin::Config. The
default name is based on the value of \*(L"moniker\*(R" in Mojolicious (\f(CW\*(C`myapp\*(C'\fR),
appended with a \f(CW\*(C`.conf\*(C'\fR extension (\f(CW\*(C`myapp.conf\*(C'\fR).
.PP
.Vb 5
\&  $ mkdir myapp
\&  $ cd myapp
\&  $ touch myapp.pl
\&  $ chmod 744 myapp.pl
\&  $ echo \*(Aq{name => "my Mojolicious application"};\*(Aq > myapp.conf
.Ve
.PP
Configuration files themselves are just Perl scripts that return a hash
reference with configuration settings of your choice. All those settings are
then available through the method \*(L"config\*(R" in Mojo and the helper
\&\*(L"config\*(R" in Mojolicious::Plugin::DefaultHelpers.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  plugin \*(AqConfig\*(Aq;
\&
\&  my $name = app\->config(\*(Aqname\*(Aq);
\&  app\->log\->debug("Welcome to $name");
\&
\&  get \*(Aq/\*(Aq => \*(Aqwith_config\*(Aq;
\&
\&  app\->start;
\&  _\|_DATA_\|_
\&  @@ with_config.html.ep
\&  <!DOCTYPE html>
\&  <html>
\&    <head><title><%= config \*(Aqname\*(Aq %></title></head>
\&    <body>Welcome to <%= config \*(Aqname\*(Aq %></body>
\&  </html>
.Ve
.PP
Alternatively you can also use configuration files in the \s-1JSON\s0 format with
Mojolicious::Plugin::JSONConfig.
.SS "Adding a plugin to your application"
.IX Subsection "Adding a plugin to your application"
To organize your code better and to prevent helpers from cluttering your
application, you can use application specific plugins.
.PP
.Vb 2
\&  $ mkdir \-p lib/MyApp/Plugin
\&  $ touch lib/MyApp/Plugin/MyHelpers.pm
.Ve
.PP
They work just like normal plugins and are also subclasses of
Mojolicious::Plugin. Nested helpers with a prefix based on the plugin name
are an easy way to avoid conflicts.
.PP
.Vb 2
\&  package MyApp::Plugin::MyHelpers;
\&  use Mojo::Base \*(AqMojolicious::Plugin\*(Aq;
\&
\&  sub register {
\&    my ($self, $app) = @_;
\&    $app\->helper(\*(Aqmy_helpers.render_with_header\*(Aq => sub {
\&      my ($c, @args) = @_;
\&      $c\->res\->headers\->header(\*(AqX\-Mojo\*(Aq => \*(AqI <3 Mojolicious!\*(Aq);
\&      $c\->render(@args);
\&    });
\&  }
\&
\&  1;
.Ve
.PP
You can have as many application specific plugins as you like, the only
difference to normal plugins is that you load them using their full class name.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  use lib \*(Aqlib\*(Aq;
\&
\&  plugin \*(AqMyApp::Plugin::MyHelpers\*(Aq;
\&
\&  get \*(Aq/\*(Aq => sub {
\&    my $c = shift;
\&    $c\->my_helpers\->render_with_header(text => \*(AqI X Mojolicious!\*(Aq);
\&  };
\&
\&  app\->start;
.Ve
.PP
Of course these plugins can contain more than just helpers, take a look at
\&\*(L"\s-1PLUGINS\s0\*(R" in Mojolicious::Plugins for a few ideas.
.SS "Adding commands to Mojolicious"
.IX Subsection "Adding commands to Mojolicious"
By now you've probably used many of the built-in commands described in
Mojolicious::Commands, but did you know that you can just add new ones and
that they will be picked up automatically by the command line interface if they
are placed in a directory from \f(CW@INC\fR?
.PP
.Vb 2
\&  package Mojolicious::Command::spy;
\&  use Mojo::Base \*(AqMojolicious::Command\*(Aq;
\&
\&  has description => \*(AqSpy on application\*(Aq;
\&  has usage       => "Usage: APPLICATION spy [TARGET]\en";
\&
\&  sub run {
\&    my ($self, @args) = @_;
\&
\&    # Leak secret passphrases
\&    if ($args[0] eq \*(Aqsecrets\*(Aq) { say for @{$self\->app\->secrets} }
\&
\&    # Leak mode
\&    elsif ($args[0] eq \*(Aqmode\*(Aq) { say $self\->app\->mode }
\&  }
\&
\&  1;
.Ve
.PP
Command line arguments are passed right through and there are many useful
attributes and methods in Mojolicious::Command that you can use or overload.
.PP
.Vb 2
\&  $ mojo spy secrets
\&  HelloWorld
\&
\&  $ ./script/myapp spy secrets
\&  secr3t
.Ve
.PP
And to make your commands application specific, just add a custom namespace to
\&\*(L"namespaces\*(R" in Mojolicious::Commands and use a class name like
\&\f(CW\*(C`MyApp::Command::spy\*(C'\fR instead of \f(CW\*(C`Mojolicious::Command::spy\*(C'\fR.
.PP
.Vb 3
\&  # Application
\&  package MyApp;
\&  use Mojo::Base \*(AqMojolicious\*(Aq;
\&
\&  sub startup {
\&    my $self = shift;
\&
\&    # Add another namespace to load commands from
\&    push @{$self\->commands\->namespaces}, \*(AqMyApp::Command\*(Aq;
\&  }
\&
\&  1;
.Ve
.PP
The options \f(CW\*(C`\-h\*(C'\fR/\f(CW\*(C`\-\-help\*(C'\fR, \f(CW\*(C`\-\-home\*(C'\fR and \f(CW\*(C`\-m\*(C'\fR/\f(CW\*(C`\-\-mode\*(C'\fR are handled
automatically by Mojolicious::Commands and are shared by all commands.
.PP
.Vb 2
\&  $ ./script/myapp spy \-m production mode
\&  production
.Ve
.PP
For a full list of shared options see \*(L"\s-1SYNOPSIS\s0\*(R" in Mojolicious::Commands.
.SS "Running code against your application"
.IX Subsection "Running code against your application"
Ever thought about running a quick one-liner against your Mojolicious
application to test something? Thanks to the command
Mojolicious::Command::eval you can do just that, the application object
itself can be accessed via \f(CW\*(C`app\*(C'\fR.
.PP
.Vb 3
\&  $ mojo generate lite_app myapp.pl
\&  $ ./myapp.pl eval \*(Aqsay for @{app\->static\->paths}\*(Aq
\&  $ ./myapp.pl eval \*(Aqsay for sort keys %{app\->renderer\->helpers}\*(Aq
.Ve
.PP
The \f(CW\*(C`verbose\*(C'\fR options will automatically print the return value or returned
data structure to \f(CW\*(C`STDOUT\*(C'\fR.
.PP
.Vb 2
\&  $ ./myapp.pl eval \-v \*(Aqapp\->static\->paths\->[0]\*(Aq
\&  $ ./myapp.pl eval \-V \*(Aqapp\->static\->paths\*(Aq
.Ve
.SS "Making your application installable"
.IX Subsection "Making your application installable"
Ever thought about releasing your Mojolicious application to \s-1CPAN\s0? It's
actually much easier than you might think.
.PP
.Vb 4
\&  $ mojo generate app MyApp
\&  $ cd my_app
\&  $ mv public lib/MyApp/
\&  $ mv templates lib/MyApp/
.Ve
.PP
The trick is to move the \f(CW\*(C`public\*(C'\fR and \f(CW\*(C`templates\*(C'\fR directories so they can get
automatically installed with the modules.
.PP
.Vb 3
\&  # Application
\&  package MyApp;
\&  use Mojo::Base \*(AqMojolicious\*(Aq;
\&
\&  use File::Basename \*(Aqdirname\*(Aq;
\&  use File::Spec::Functions \*(Aqcatdir\*(Aq;
\&
\&  # Every CPAN module needs a version
\&  our $VERSION = \*(Aq1.0\*(Aq;
\&
\&  sub startup {
\&    my $self = shift;
\&
\&    # Switch to installable home directory
\&    $self\->home\->parse(catdir(dirname(_\|_FILE_\|_), \*(AqMyApp\*(Aq));
\&
\&    # Switch to installable "public" directory
\&    $self\->static\->paths\->[0] = $self\->home\->rel_dir(\*(Aqpublic\*(Aq);
\&
\&    # Switch to installable "templates" directory
\&    $self\->renderer\->paths\->[0] = $self\->home\->rel_dir(\*(Aqtemplates\*(Aq);
\&
\&    $self\->plugin(\*(AqPODRenderer\*(Aq);
\&
\&    my $r = $self\->routes;
\&    $r\->get(\*(Aq/welcome\*(Aq)\->to(\*(Aqexample#welcome\*(Aq);
\&  }
\&
\&  1;
.Ve
.PP
Finally there is just one small change to be made to the application script. The
shebang line becomes the recommended \f(CW\*(C`#!perl\*(C'\fR, which the toolchain can rewrite
to the proper shebang during installation.
.PP
.Vb 1
\&  #!perl
\&
\&  use strict;
\&  use warnings;
\&
\&  use FindBin;
\&  BEGIN { unshift @INC, "$FindBin::Bin/../lib" }
\&  use Mojolicious::Commands;
\&
\&  # Start command line interface for application
\&  Mojolicious::Commands\->start_app(\*(AqMyApp\*(Aq);
.Ve
.PP
That's really everything, now you can package your application like any other
\&\s-1CPAN\s0 module.
.PP
.Vb 5
\&  $ ./script/my_app generate makefile
\&  $ perl Makefile.PL
\&  $ make test
\&  $ make manifest
\&  $ make dist
.Ve
.PP
And if you have a \s-1PAUSE\s0 account (which can be requested at
<http://pause.perl.org>) even upload it.
.PP
.Vb 1
\&  $ mojo cpanify \-u USER \-p PASS MyApp\-0.01.tar.gz
.Ve
.SS "Hello World"
.IX Subsection "Hello World"
If every byte matters this is the smallest \f(CW\*(C`Hello World\*(C'\fR application you can
write with Mojolicious::Lite.
.PP
.Vb 3
\&  use Mojolicious::Lite;
\&  any {text => \*(AqHello World!\*(Aq};
\&  app\->start;
.Ve
.PP
It works because all routes without a pattern default to \f(CW\*(C`/\*(C'\fR and automatic
rendering kicks in even if no actual code gets executed by the router. The
renderer just picks up the \f(CW\*(C`text\*(C'\fR value from the stash and generates a
response.
.SS "Hello World one-liners"
.IX Subsection "Hello World one-liners"
The \f(CW\*(C`Hello World\*(C'\fR example above can get even a little bit shorter in an ojo
one-liner.
.PP
.Vb 1
\&  $ perl \-Mojo \-E \*(Aqa({text => "Hello World!"})\->start\*(Aq daemon
.Ve
.PP
And you can use all the commands from Mojolicious::Commands.
.PP
.Vb 1
\&  $ perl \-Mojo \-E \*(Aqa({text => "Hello World!"})\->start\*(Aq get \-v /
.Ve
.SH "MORE"
.IX Header "MORE"
You can continue with Mojolicious::Guides now or take a look at the
Mojolicious wiki <http://github.com/kraih/mojo/wiki>, which contains a lot
more documentation and examples by many different authors.
.SH "SUPPORT"
.IX Header "SUPPORT"
If you have any questions the documentation might not yet answer, don't
hesitate to ask on the
mailing list <http://groups.google.com/group/mojolicious> or the official \s-1IRC\s0
channel \f(CW\*(C`#mojo\*(C'\fR on \f(CW\*(C`irc.perl.org\*(C'\fR
(chat now! <https://chat.mibbit.com/?channel=%23mojo&server=irc.perl.org>).
