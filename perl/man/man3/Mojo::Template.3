.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojo::Template 3"
.TH Mojo::Template 3 "2016-07-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::Template \- Perl\-ish templates
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::Template;
\&
\&  # Use Perl modules
\&  my $mt = Mojo::Template\->new;
\&  say $mt\->render(<<\*(AqEOF\*(Aq);
\&  % use Time::Piece;
\&  <div>
\&    % my $now = localtime;
\&    Time: <%= $now\->hms %>
\&  </div>
\&  EOF
\&
\&  # Render with arguments
\&  say $mt\->render(<<\*(AqEOF\*(Aq, [1 .. 13], \*(AqHello World!\*(Aq);
\&  % my ($numbers, $title) = @_;
\&  <div>
\&    <h1><%= $title %></h1>
\&    % for my $i (@$numbers) {
\&      Test <%= $i %>
\&    % }
\&  </div>
\&  EOF
\&
\&  # Render with named variables
\&  say $mt\->vars(1)\->render(<<\*(AqEOF\*(Aq, {title => \*(AqHello World!\*(Aq});
\&  <div>
\&    <h1><%= $title %></h1>
\&    %= 5 + 5
\&  </div>
\&  EOF
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::Template is a minimalistic, fast, and very Perl-ish template engine,
designed specifically for all those small tasks that come up during big
projects. Like preprocessing a configuration file, generating text from heredocs
and stuff like that.
.PP
See Mojolicious::Guides::Rendering for information on how to generate
content with the Mojolicious renderer.
.SH "SYNTAX"
.IX Header "SYNTAX"
For all templates strict, warnings, utf8 and Perl 5.10
features are automatically enabled.
.PP
.Vb 10
\&  <% Perl code %>
\&  <%= Perl expression, replaced with result %>
\&  <%== Perl expression, replaced with XML escaped result %>
\&  <%# Comment, useful for debugging %>
\&  <%% Replaced with "<%", useful for generating templates %>
\&  % Perl code line, treated as "<% line =%>" (explained later)
\&  %= Perl expression line, treated as "<%= line %>"
\&  %== Perl expression line, treated as "<%== line %>"
\&  %# Comment line, useful for debugging
\&  %% Replaced with "%", useful for generating templates
.Ve
.PP
Escaping behavior can be reversed with the \*(L"auto_escape\*(R" attribute, this is
the default in Mojolicious \f(CW\*(C`.ep\*(C'\fR templates, for example.
.PP
.Vb 2
\&  <%= Perl expression, replaced with XML escaped result %>
\&  <%== Perl expression, replaced with result %>
.Ve
.PP
Mojo::ByteStream objects are always excluded from automatic escaping.
.PP
.Vb 2
\&  % use Mojo::ByteStream \*(Aqb\*(Aq;
\&  <%= b(\*(Aq<div>excluded!</div>\*(Aq) %>
.Ve
.PP
Whitespace characters around tags can be trimmed by adding an additional equal
sign to the end of a tag.
.PP
.Vb 3
\&  <% for (1 .. 3) { %>
\&    <%= \*(AqTrim all whitespace characters around this expression\*(Aq =%>
\&  <% } %>
.Ve
.PP
Newline characters can be escaped with a backslash.
.PP
.Vb 2
\&  This is <%= 1 + 1 %> a\e
\&  single line
.Ve
.PP
And a backslash in front of a newline character can be escaped with another
backslash.
.PP
.Vb 3
\&  This will <%= 1 + 1 %> result\e\e
\&  in multiple\e\e
\&  lines
.Ve
.PP
You can capture whole template blocks for reuse later with the \f(CW\*(C`begin\*(C'\fR and
\&\f(CW\*(C`end\*(C'\fR keywords. Just be aware that both keywords are part of the surrounding
tag and not actual Perl code, so there can only be whitespace after \f(CW\*(C`begin\*(C'\fR
and before \f(CW\*(C`end\*(C'\fR.
.PP
.Vb 6
\&  <% my $block = begin %>
\&    <% my $name = shift; =%>
\&    Hello <%= $name %>.
\&  <% end %>
\&  <%= $block\->(\*(AqBaerbel\*(Aq) %>
\&  <%= $block\->(\*(AqWolfgang\*(Aq) %>
.Ve
.PP
Perl lines can also be indented freely.
.PP
.Vb 6
\&  % my $block = begin
\&    % my $name = shift;
\&    Hello <%= $name %>.
\&  % end
\&  %= $block\->(\*(AqBaerbel\*(Aq)
\&  %= $block\->(\*(AqWolfgang\*(Aq)
.Ve
.PP
Mojo::Template templates get compiled to a Perl subroutine, that means you
can access arguments simply via \f(CW@_\fR.
.PP
.Vb 3
\&  % my ($foo, $bar) = @_;
\&  % my $x = shift;
\&  test 123 <%= $foo %>
.Ve
.PP
The compilation of templates to Perl code can make debugging a bit tricky, but
Mojo::Template will return Mojo::Exception objects that stringify to
error messages with context.
.PP
.Vb 6
\&  Bareword "xx" not allowed while "strict subs" in use at template line 4.
\&  2: </head>
\&  3: <body>
\&  4: % my $i = 2; xx
\&  5: %= $i * 2
\&  6: </body>
.Ve
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Mojo::Template implements the following attributes.
.SS "auto_escape"
.IX Subsection "auto_escape"
.Vb 2
\&  my $bool = $mt\->auto_escape;
\&  $mt      = $mt\->auto_escape($bool);
.Ve
.PP
Activate automatic escaping.
.PP
.Vb 2
\&  # "&lt;html&gt;"
\&  Mojo::Template\->new(auto_escape => 1)\->render("<%= \*(Aq<html>\*(Aq %>");
.Ve
.SS "append"
.IX Subsection "append"
.Vb 2
\&  my $code = $mt\->append;
\&  $mt      = $mt\->append(\*(Aqwarn "Processed template"\*(Aq);
.Ve
.PP
Append Perl code to compiled template. Note that this code should not contain
newline characters, or line numbers in error messages might end up being wrong.
.SS "capture_end"
.IX Subsection "capture_end"
.Vb 2
\&  my $end = $mt\->capture_end;
\&  $mt     = $mt\->capture_end(\*(Aqend\*(Aq);
.Ve
.PP
Keyword indicating the end of a capture block, defaults to \f(CW\*(C`end\*(C'\fR.
.PP
.Vb 3
\&  <% my $block = begin %>
\&    Some data!
\&  <% end %>
.Ve
.SS "capture_start"
.IX Subsection "capture_start"
.Vb 2
\&  my $start = $mt\->capture_start;
\&  $mt       = $mt\->capture_start(\*(Aqbegin\*(Aq);
.Ve
.PP
Keyword indicating the start of a capture block, defaults to \f(CW\*(C`begin\*(C'\fR.
.PP
.Vb 3
\&  <% my $block = begin %>
\&    Some data!
\&  <% end %>
.Ve
.SS "code"
.IX Subsection "code"
.Vb 2
\&  my $code = $mt\->code;
\&  $mt      = $mt\->code($code);
.Ve
.PP
Perl code for template if available.
.SS "comment_mark"
.IX Subsection "comment_mark"
.Vb 2
\&  my $mark = $mt\->comment_mark;
\&  $mt      = $mt\->comment_mark(\*(Aq#\*(Aq);
.Ve
.PP
Character indicating the start of a comment, defaults to \f(CW\*(C`#\*(C'\fR.
.PP
.Vb 1
\&  <%# This is a comment %>
.Ve
.SS "compiled"
.IX Subsection "compiled"
.Vb 2
\&  my $compiled = $mt\->compiled;
\&  $mt          = $mt\->compiled($compiled);
.Ve
.PP
Compiled template code if available.
.SS "encoding"
.IX Subsection "encoding"
.Vb 2
\&  my $encoding = $mt\->encoding;
\&  $mt          = $mt\->encoding(\*(AqUTF\-8\*(Aq);
.Ve
.PP
Encoding used for template files, defaults to \f(CW\*(C`UTF\-8\*(C'\fR.
.SS "escape"
.IX Subsection "escape"
.Vb 2
\&  my $cb = $mt\->escape;
\&  $mt    = $mt\->escape(sub {...});
.Ve
.PP
A callback used to escape the results of escaped expressions, defaults to
\&\*(L"xml_escape\*(R" in Mojo::Util.
.PP
.Vb 4
\&  $mt\->escape(sub {
\&    my $str = shift;
\&    return reverse $str;
\&  });
.Ve
.SS "escape_mark"
.IX Subsection "escape_mark"
.Vb 2
\&  my $mark = $mt\->escape_mark;
\&  $mt      = $mt\->escape_mark(\*(Aq=\*(Aq);
.Ve
.PP
Character indicating the start of an escaped expression, defaults to \f(CW\*(C`=\*(C'\fR.
.PP
.Vb 1
\&  <%== $foo %>
.Ve
.SS "expression_mark"
.IX Subsection "expression_mark"
.Vb 2
\&  my $mark = $mt\->expression_mark;
\&  $mt      = $mt\->expression_mark(\*(Aq=\*(Aq);
.Ve
.PP
Character indicating the start of an expression, defaults to \f(CW\*(C`=\*(C'\fR.
.PP
.Vb 1
\&  <%= $foo %>
.Ve
.SS "line_start"
.IX Subsection "line_start"
.Vb 2
\&  my $start = $mt\->line_start;
\&  $mt       = $mt\->line_start(\*(Aq%\*(Aq);
.Ve
.PP
Character indicating the start of a code line, defaults to \f(CW\*(C`%\*(C'\fR.
.PP
.Vb 1
\&  % $foo = 23;
.Ve
.SS "name"
.IX Subsection "name"
.Vb 2
\&  my $name = $mt\->name;
\&  $mt      = $mt\->name(\*(Aqfoo.mt\*(Aq);
.Ve
.PP
Name of template currently being processed, defaults to \f(CW\*(C`template\*(C'\fR. Note that
this value should not contain quotes or newline characters, or error messages
might end up being wrong.
.SS "namespace"
.IX Subsection "namespace"
.Vb 2
\&  my $namespace = $mt\->namespace;
\&  $mt           = $mt\->namespace(\*(Aqmain\*(Aq);
.Ve
.PP
Namespace used to compile templates, defaults to \f(CW\*(C`Mojo::Template::SandBox\*(C'\fR.
Note that namespaces should only be shared very carefully between templates,
since functions and global variables will not be cleared automatically.
.SS "prepend"
.IX Subsection "prepend"
.Vb 2
\&  my $code = $mt\->prepend;
\&  $mt      = $mt\->prepend(\*(Aqmy $self = shift;\*(Aq);
.Ve
.PP
Prepend Perl code to compiled template. Note that this code should not contain
newline characters, or line numbers in error messages might end up being wrong.
.SS "replace_mark"
.IX Subsection "replace_mark"
.Vb 2
\&  my $mark = $mt\->replace_mark;
\&  $mt      = $mt\->replace_mark(\*(Aq%\*(Aq);
.Ve
.PP
Character used for escaping the start of a tag or line, defaults to \f(CW\*(C`%\*(C'\fR.
.PP
.Vb 1
\&  <%% my $foo = 23; %>
.Ve
.SS "tag_start"
.IX Subsection "tag_start"
.Vb 2
\&  my $start = $mt\->tag_start;
\&  $mt       = $mt\->tag_start(\*(Aq<%\*(Aq);
.Ve
.PP
Characters indicating the start of a tag, defaults to \f(CW\*(C`<%\*(C'\fR.
.PP
.Vb 1
\&  <% $foo = 23; %>
.Ve
.SS "tag_end"
.IX Subsection "tag_end"
.Vb 2
\&  my $end = $mt\->tag_end;
\&  $mt     = $mt\->tag_end(\*(Aq%>\*(Aq);
.Ve
.PP
Characters indicating the end of a tag, defaults to \f(CW\*(C`%>\*(C'\fR.
.PP
.Vb 1
\&  <%= $foo %>
.Ve
.SS "tree"
.IX Subsection "tree"
.Vb 2
\&  my $tree = $mt\->tree;
\&  $mt      = $mt\->tree([[\*(Aqtext\*(Aq, \*(Aqfoo\*(Aq], [\*(Aqline\*(Aq]]);
.Ve
.PP
Template in parsed form if available. Note that this structure should only be
used very carefully since it is very dynamic.
.SS "trim_mark"
.IX Subsection "trim_mark"
.Vb 2
\&  my $mark = $mt\->trim_mark;
\&  $mt      = $mt\->trim_mark(\*(Aq\-\*(Aq);
.Ve
.PP
Character activating automatic whitespace trimming, defaults to \f(CW\*(C`=\*(C'\fR.
.PP
.Vb 1
\&  <%= $foo =%>
.Ve
.SS "unparsed"
.IX Subsection "unparsed"
.Vb 2
\&  my $unparsed = $mt\->unparsed;
\&  $mt          = $mt\->unparsed(\*(Aq<%= 1 + 1 %>\*(Aq);
.Ve
.PP
Raw unparsed template if available.
.SS "vars"
.IX Subsection "vars"
.Vb 2
\&  my $bool = $mt\->vars;
\&  $mt      = $mt\->vars($bool);
.Ve
.PP
Instead of a list of values, use a hash reference with named variables to pass
data to templates.
.PP
.Vb 2
\&  # "works!"
\&  Mojo::Template\->new(vars => 1)\->render(\*(Aq<%= $test %>!\*(Aq, {test => \*(Aqworks\*(Aq});
.Ve
.SH "METHODS"
.IX Header "METHODS"
Mojo::Template inherits all methods from Mojo::Base and implements the
following new ones.
.SS "parse"
.IX Subsection "parse"
.Vb 1
\&  $mt = $mt\->parse(\*(Aq<%= 1 + 1 %>\*(Aq);
.Ve
.PP
Parse template into \*(L"tree\*(R".
.SS "process"
.IX Subsection "process"
.Vb 3
\&  my $output = $mt\->process;
\&  my $output = $mt\->process(@args);
\&  my $output = $mt\->process({foo => \*(Aqbar\*(Aq});
.Ve
.PP
Process previously parsed template and return the result, or a
Mojo::Exception object if rendering failed.
.PP
.Vb 2
\&  # Parse and process
\&  say Mojo::Template\->new\->parse(\*(AqHello <%= $_[0] %>\*(Aq)\->process(\*(AqBender\*(Aq);
\&
\&  # Reuse template (for much better performance)
\&  my $mt = Mojo::Template\->new;
\&  say $mt\->render(\*(AqHello <%= $_[0] %>!\*(Aq, \*(AqBender\*(Aq);
\&  say $mt\->process(\*(AqFry\*(Aq);
\&  say $mt\->process(\*(AqLeela\*(Aq);
.Ve
.SS "render"
.IX Subsection "render"
.Vb 3
\&  my $output = $mt\->render(\*(Aq<%= 1 + 1 %>\*(Aq);
\&  my $output = $mt\->render(\*(Aq<%= shift() + shift() %>\*(Aq, @args);
\&  my $output = $mt\->render(\*(Aq<%= $foo %>\*(Aq, {foo => \*(Aqbar\*(Aq});
.Ve
.PP
Render template and return the result, or a Mojo::Exception object if
rendering failed.
.PP
.Vb 2
\&  # Longer version
\&  my $output = $mt\->parse(\*(Aq<%= 1 + 1 %>\*(Aq)\->process;
\&
\&  # Render with arguments
\&  say Mojo::Template\->new\->render(\*(Aq<%= $_[0] %>\*(Aq, \*(Aqbar\*(Aq);
\&
\&  # Render with named variables
\&  say Mojo::Template\->new(vars => 1)\->render(\*(Aq<%= $foo %>\*(Aq, {foo => \*(Aqbar\*(Aq});
.Ve
.SS "render_file"
.IX Subsection "render_file"
.Vb 3
\&  my $output = $mt\->render_file(\*(Aq/tmp/foo.mt\*(Aq);
\&  my $output = $mt\->render_file(\*(Aq/tmp/foo.mt\*(Aq, @args);
\&  my $output = $mt\->render_file(\*(Aq/tmp/bar.mt\*(Aq, {foo => \*(Aqbar\*(Aq});
.Ve
.PP
Same as \*(L"render\*(R", but renders a template file.
.SH "DEBUGGING"
.IX Header "DEBUGGING"
You can set the \f(CW\*(C`MOJO_TEMPLATE_DEBUG\*(C'\fR environment variable to get some
advanced diagnostics information printed to \f(CW\*(C`STDERR\*(C'\fR.
.PP
.Vb 1
\&  MOJO_TEMPLATE_DEBUG=1
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicious.org>.
