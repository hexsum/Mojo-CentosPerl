.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojo::Loader 3"
.TH Mojo::Loader 3 "2016-08-16" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::Loader \- Load all kinds of things
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::Loader qw(data_section find_modules load_class);
\&
\&  # Find modules in a namespace
\&  for my $module (find_modules \*(AqSome::Namespace\*(Aq) {
\&
\&    # Load them safely
\&    my $e = load_class $module;
\&    warn qq{Loading "$module" failed: $e} and next if ref $e;
\&
\&    # And extract files from the DATA section
\&    say data_section($module, \*(Aqsome_file.txt\*(Aq);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::Loader is a class loader and plugin framework. Aside from finding
modules and loading classes, it allows multiple files to be stored in the
\&\f(CW\*(C`DATA\*(C'\fR section of a class, which can then be accessed individually.
.PP
.Vb 1
\&  package Foo;
\&
\&  1;
\&  _\|_DATA_\|_
\&
\&  @@ test.txt
\&  This is the first file.
\&
\&  @@ test2.html (base64)
\&  VGhpcyBpcyB0aGUgc2Vjb25kIGZpbGUu
\&
\&  @@ test
\&  This is the
\&  third file.
.Ve
.PP
Each file has a header starting with \f(CW\*(C`@@\*(C'\fR, followed by the file name and
optional instructions for decoding its content. Currently only the Base64
encoding is supported, which can be quite convenient for the storage of binary
data.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
Mojo::Loader implements the following functions, which can be imported
individually.
.SS "data_section"
.IX Subsection "data_section"
.Vb 2
\&  my $all   = data_section \*(AqFoo::Bar\*(Aq;
\&  my $index = data_section \*(AqFoo::Bar\*(Aq, \*(Aqindex.html\*(Aq;
.Ve
.PP
Extract embedded file from the \f(CW\*(C`DATA\*(C'\fR section of a class, all files will be
cached once they have been accessed for the first time.
.PP
.Vb 2
\&  # List embedded files
\&  say for keys %{data_section \*(AqFoo::Bar\*(Aq};
.Ve
.SS "file_is_binary"
.IX Subsection "file_is_binary"
.Vb 1
\&  my $bool = file_is_binary \*(AqFoo::Bar\*(Aq, \*(Aqtest.png\*(Aq;
.Ve
.PP
Check if embedded file from the \f(CW\*(C`DATA\*(C'\fR section of a class was Base64 encoded.
.SS "find_packages"
.IX Subsection "find_packages"
.Vb 1
\&  my @pkgs = find_packages \*(AqMyApp::Namespace\*(Aq;
.Ve
.PP
Search for packages in a namespace non-recursively.
.SS "find_modules"
.IX Subsection "find_modules"
.Vb 1
\&  my @modules = find_modules \*(AqMyApp::Namespace\*(Aq;
.Ve
.PP
Search for modules in a namespace non-recursively.
.SS "load_class"
.IX Subsection "load_class"
.Vb 1
\&  my $e = load_class \*(AqFoo::Bar\*(Aq;
.Ve
.PP
Load a class and catch exceptions, returns a false value if loading was
successful, a true value if the class has already been loaded, or a
Mojo::Exception object if loading failed. Note that classes are checked for a
\&\f(CW\*(C`new\*(C'\fR method to see if they are already loaded.
.PP
.Vb 4
\&  # Handle exceptions
\&  if (my $e = load_class \*(AqFoo::Bar\*(Aq) {
\&    die ref $e ? "Exception: $e" : \*(AqNot found!\*(Aq;
\&  }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicious.org>.
